{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"MedGemma Hackathon","text":"<p>This repository hosts the MedGemma hackathon demo for extracting atomic inclusion/exclusion criteria from clinical trial protocols, grounding them to SNOMED via UBKG, mapping field/relation/value for screening, and enabling a human-in-the-loop (HITL) review experience.</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Overview: <code>docs/overview/project.md</code></li> <li>Architecture: <code>docs/overview/architecture.md</code></li> <li>Getting Started: <code>docs/overview/getting-started.md</code></li> <li>Hackathon Plan: <code>docs/overview/hackathon-plan.md</code></li> <li>API Spec: <code>docs/api/api_spec.md</code></li> <li>Components: <code>docs/components-overview.md</code></li> </ul>"},{"location":"#demo-goals","title":"Demo Goals","text":"<ul> <li>Extract atomic criteria with evidence snippets.</li> <li>Ground criteria to SNOMED with ranked candidates and confidence.</li> <li>Map criteria to field/relation/value (e.g., <code>demographics.age &gt; 75</code>).</li> <li>Provide a HITL UI for nurse review and corrections.</li> <li>Capture edits for training and evaluation.</li> </ul>"},{"location":"#repo-layout","title":"Repo Layout","text":"<pre><code>components/     Service components (API, extraction, grounding, UI, etc.)\ndocs/           MkDocs documentation\nscripts/        Utility scripts (protocol download, component creation, etc.)\ninstructions/   Planning documents\n</code></pre>"},{"location":"#scripts","title":"Scripts","text":"<p>The <code>scripts/</code> directory contains utility scripts for common tasks:</p> <ul> <li>Protocol Download: <code>scripts/download_protocol_sources.py</code> - Downloads clinical trial protocol PDFs from multiple sources (DAC, ClinicalTrials.gov, BMJ Open, JMIR)</li> <li>Component Creation: <code>scripts/create_component.sh</code> - Initializes new components with proper structure</li> <li>Documentation: <code>scripts/generate_components_overview.py</code> and <code>scripts/update_root_navigation.py</code> - Auto-generate documentation</li> </ul> <p>See Getting Started for detailed usage instructions.</p>"},{"location":"components-overview/","title":"Components Overview","text":"<p>This page lists all available components in the monorepo, grouped by category. Click a component name to view its documentation.</p>"},{"location":"components-overview/#others-components","title":"Others Components","text":"Name Description Owner Api Service api-service component Unknown Data Pipeline data-pipeline component Unknown Evaluation evaluation component Unknown Extraction Service extraction-service component Unknown Grounding Service grounding-service component Unknown Hitl Ui React/Vite frontend for nurse review of extracted criteria and evidence. Unknown Shared shared component Unknown <p>Total Components: 7</p> <p>This overview is automatically generated from component pyproject.toml files and README files.</p>"},{"location":"api/api_spec/","title":"API Spec","text":"<p>The OpenAPI spec will live in this folder as <code>api_spec.yaml</code>.</p> <p>Endpoints (minimal):</p> <ul> <li><code>POST /v1/protocols</code></li> <li><code>POST /v1/protocols/{protocolId}/extract</code></li> <li><code>GET /v1/protocols/{protocolId}/criteria</code></li> <li><code>PATCH /v1/criteria/{criterionId}</code></li> <li><code>POST /v1/criteria/{criterionId}/ground</code> (SNOMED candidates + field/relation/value mapping)</li> <li><code>POST /v1/hitl/feedback</code></li> </ul>"},{"location":"api-service/","title":"api-service","text":"<p>FastAPI service that orchestrates protocol ingestion, extraction, grounding (SNOMED + field/relation/value), and HITL feedback. This is the entry point for the demo API.</p>"},{"location":"api-service/#responsibilities","title":"Responsibilities","text":"<ul> <li>Expose REST endpoints for protocols, criteria, grounding (SNOMED + field mapping), and HITL edits.</li> <li>Validate request payloads and manage response shapes.</li> <li>Orchestrate calls to extraction and grounding components.</li> </ul>"},{"location":"api-service/#key-endpoints-wireframe","title":"Key Endpoints (wireframe)","text":"<ul> <li><code>POST /v1/protocols</code></li> <li><code>POST /v1/protocols/{protocol_id}/extract</code></li> <li><code>GET /v1/protocols/{protocol_id}/criteria</code></li> <li><code>PATCH /v1/criteria/{criterion_id}</code></li> <li><code>POST /v1/criteria/{criterion_id}/ground</code></li> <li><code>POST /v1/hitl/feedback</code></li> </ul>"},{"location":"api-service/#running-locally","title":"Running Locally","text":"<pre><code>uv sync\nuv run uvicorn api_service.main:app --reload\n</code></pre>"},{"location":"api-service/#example-usage","title":"Example Usage","text":"<pre><code>curl -X POST http://localhost:8000/v1/protocols \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\":\"Trial A\",\"document_text\":\"Inclusion: ...\"}'\n</code></pre>"},{"location":"api-service/#tests","title":"Tests","text":"<pre><code>make check-all\n</code></pre>"},{"location":"api-service/#configuration-planned","title":"Configuration (planned)","text":"<ul> <li><code>DATABASE_URL</code> for persistence.</li> <li><code>EXTRACTION_SERVICE_URL</code> for extraction orchestration.</li> <li><code>GROUNDING_SERVICE_URL</code> for UBKG grounding.</li> </ul>"},{"location":"api-service/docs/api/","title":"api-service API Reference","text":"<p>This page contains automatically generated API documentation for the api-service component.</p>"},{"location":"api-service/docs/api/#api-documentation","title":"API Documentation","text":""},{"location":"api-service/docs/api/#api_service","title":"api_service","text":"<p>api-service package.</p>"},{"location":"api-service/docs/api/#api_service-modules","title":"Modules","text":""},{"location":"api-service/docs/api/#api_service.dependencies","title":"dependencies","text":"<p>FastAPI dependencies for shared resources.</p>"},{"location":"api-service/docs/api/#api_service.dependencies-classes","title":"Classes","text":""},{"location":"api-service/docs/api/#api_service.dependencies-functions","title":"Functions","text":""},{"location":"api-service/docs/api/#api_service.dependencies.get_storage","title":"get_storage","text":"<pre><code>get_storage() -&gt; Storage\n</code></pre> <p>Provide a storage instance for request handlers.</p> Source code in <code>components/api-service/src/api_service/dependencies.py</code> <pre><code>def get_storage() -&gt; Storage:\n    \"\"\"Provide a storage instance for request handlers.\"\"\"\n    return Storage(get_engine())\n</code></pre>"},{"location":"api-service/docs/api/#api_service.main","title":"main","text":"<p>API service wireframe for the MedGemma hackathon demo.</p>"},{"location":"api-service/docs/api/#api_service.main-classes","title":"Classes","text":""},{"location":"api-service/docs/api/#api_service.main.ProtocolCreateRequest","title":"ProtocolCreateRequest","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\n              flowchart TD\n              api_service.main.ProtocolCreateRequest[ProtocolCreateRequest]\n\n              \n\n              click api_service.main.ProtocolCreateRequest href \"\" \"api_service.main.ProtocolCreateRequest\"\n            </code></pre> <p>Request payload for creating a protocol entry.</p>"},{"location":"api-service/docs/api/#api_service.main.ProtocolResponse","title":"ProtocolResponse","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\n              flowchart TD\n              api_service.main.ProtocolResponse[ProtocolResponse]\n\n              \n\n              click api_service.main.ProtocolResponse href \"\" \"api_service.main.ProtocolResponse\"\n            </code></pre> <p>Response payload for a created protocol.</p>"},{"location":"api-service/docs/api/#api_service.main.CriterionResponse","title":"CriterionResponse","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\n              flowchart TD\n              api_service.main.CriterionResponse[CriterionResponse]\n\n              \n\n              click api_service.main.CriterionResponse href \"\" \"api_service.main.CriterionResponse\"\n            </code></pre> <p>Response payload for an extracted criterion.</p>"},{"location":"api-service/docs/api/#api_service.main.CriteriaListResponse","title":"CriteriaListResponse","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\n              flowchart TD\n              api_service.main.CriteriaListResponse[CriteriaListResponse]\n\n              \n\n              click api_service.main.CriteriaListResponse href \"\" \"api_service.main.CriteriaListResponse\"\n            </code></pre> <p>Response payload for listing criteria.</p>"},{"location":"api-service/docs/api/#api_service.main.ExtractionResponse","title":"ExtractionResponse","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\n              flowchart TD\n              api_service.main.ExtractionResponse[ExtractionResponse]\n\n              \n\n              click api_service.main.ExtractionResponse href \"\" \"api_service.main.ExtractionResponse\"\n            </code></pre> <p>Response payload for extraction trigger.</p>"},{"location":"api-service/docs/api/#api_service.main.CriterionUpdateRequest","title":"CriterionUpdateRequest","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\n              flowchart TD\n              api_service.main.CriterionUpdateRequest[CriterionUpdateRequest]\n\n              \n\n              click api_service.main.CriterionUpdateRequest href \"\" \"api_service.main.CriterionUpdateRequest\"\n            </code></pre> <p>Payload for updating a criterion.</p>"},{"location":"api-service/docs/api/#api_service.main.CriterionUpdateResponse","title":"CriterionUpdateResponse","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\n              flowchart TD\n              api_service.main.CriterionUpdateResponse[CriterionUpdateResponse]\n\n              \n\n              click api_service.main.CriterionUpdateResponse href \"\" \"api_service.main.CriterionUpdateResponse\"\n            </code></pre> <p>Response payload after updating a criterion.</p>"},{"location":"api-service/docs/api/#api_service.main.GroundingCandidateResponse","title":"GroundingCandidateResponse","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\n              flowchart TD\n              api_service.main.GroundingCandidateResponse[GroundingCandidateResponse]\n\n              \n\n              click api_service.main.GroundingCandidateResponse href \"\" \"api_service.main.GroundingCandidateResponse\"\n            </code></pre> <p>Response payload for grounding candidates.</p>"},{"location":"api-service/docs/api/#api_service.main.FieldMappingResponse","title":"FieldMappingResponse","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\n              flowchart TD\n              api_service.main.FieldMappingResponse[FieldMappingResponse]\n\n              \n\n              click api_service.main.FieldMappingResponse href \"\" \"api_service.main.FieldMappingResponse\"\n            </code></pre> <p>Response payload for a field mapping suggestion.</p>"},{"location":"api-service/docs/api/#api_service.main.GroundingResponse","title":"GroundingResponse","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\n              flowchart TD\n              api_service.main.GroundingResponse[GroundingResponse]\n\n              \n\n              click api_service.main.GroundingResponse href \"\" \"api_service.main.GroundingResponse\"\n            </code></pre> <p>Response payload for grounding a criterion.</p>"},{"location":"api-service/docs/api/#api_service.main.HitlFeedbackRequest","title":"HitlFeedbackRequest","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\n              flowchart TD\n              api_service.main.HitlFeedbackRequest[HitlFeedbackRequest]\n\n              \n\n              click api_service.main.HitlFeedbackRequest href \"\" \"api_service.main.HitlFeedbackRequest\"\n            </code></pre> <p>Payload for HITL feedback actions.</p>"},{"location":"api-service/docs/api/#api_service.main-functions","title":"Functions","text":""},{"location":"api-service/docs/api/#api_service.main.lifespan","title":"lifespan  <code>async</code>","text":"<pre><code>lifespan(app_instance: FastAPI) -&gt; AsyncIterator[None]\n</code></pre> <p>Initialize and teardown app state for the lifespan scope.</p> Source code in <code>components/api-service/src/api_service/main.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(app_instance: FastAPI) -&gt; AsyncIterator[None]:\n    \"\"\"Initialize and teardown app state for the lifespan scope.\"\"\"\n    init_db()\n    yield\n</code></pre>"},{"location":"api-service/docs/api/#api_service.main.create_protocol","title":"create_protocol","text":"<pre><code>create_protocol(payload: ProtocolCreateRequest, storage: Storage = Depends(get_storage)) -&gt; ProtocolResponse\n</code></pre> <p>Create a protocol record and initial document entry.</p> Source code in <code>components/api-service/src/api_service/main.py</code> <pre><code>@app.post(\"/v1/protocols\")\ndef create_protocol(\n    payload: ProtocolCreateRequest,\n    storage: Storage = Depends(get_storage),\n) -&gt; ProtocolResponse:\n    \"\"\"Create a protocol record and initial document entry.\"\"\"\n    protocol = storage.create_protocol(\n        title=payload.title, document_text=payload.document_text\n    )\n    return ProtocolResponse(protocol_id=protocol.id, title=protocol.title)\n</code></pre>"},{"location":"api-service/docs/api/#api_service.main.extract_criteria","title":"extract_criteria","text":"<pre><code>extract_criteria(protocol_id: str, storage: Storage = Depends(get_storage)) -&gt; ExtractionResponse\n</code></pre> <p>Trigger extraction of atomic criteria for a protocol.</p> Source code in <code>components/api-service/src/api_service/main.py</code> <pre><code>@app.post(\"/v1/protocols/{protocol_id}/extract\")\ndef extract_criteria(\n    protocol_id: str,\n    storage: Storage = Depends(get_storage),\n) -&gt; ExtractionResponse:\n    \"\"\"Trigger extraction of atomic criteria for a protocol.\"\"\"\n    protocol = storage.get_protocol(protocol_id)\n    if protocol is None:\n        raise HTTPException(status_code=404, detail=\"Protocol not found\")\n\n    extracted = extraction_pipeline.extract_criteria(protocol.document_text)\n    stored = storage.replace_criteria(\n        protocol_id=protocol_id,\n        extracted=extracted,\n    )\n    return ExtractionResponse(\n        protocol_id=protocol_id, status=\"completed\", criteria_count=len(stored)\n    )\n</code></pre>"},{"location":"api-service/docs/api/#api_service.main.list_criteria","title":"list_criteria","text":"<pre><code>list_criteria(protocol_id: str, storage: Storage = Depends(get_storage)) -&gt; CriteriaListResponse\n</code></pre> <p>List criteria generated for a protocol.</p> Source code in <code>components/api-service/src/api_service/main.py</code> <pre><code>@app.get(\"/v1/protocols/{protocol_id}/criteria\")\ndef list_criteria(\n    protocol_id: str,\n    storage: Storage = Depends(get_storage),\n) -&gt; CriteriaListResponse:\n    \"\"\"List criteria generated for a protocol.\"\"\"\n    protocol = storage.get_protocol(protocol_id)\n    if protocol is None:\n        raise HTTPException(status_code=404, detail=\"Protocol not found\")\n\n    criteria = [\n        _criterion_to_response(criterion)\n        for criterion in storage.list_criteria(protocol_id)\n    ]\n    return CriteriaListResponse(protocol_id=protocol_id, criteria=criteria)\n</code></pre>"},{"location":"api-service/docs/api/#api_service.main.update_criterion","title":"update_criterion","text":"<pre><code>update_criterion(criterion_id: str, payload: Optional[CriterionUpdateRequest] = Body(default=None), storage: Storage = Depends(get_storage)) -&gt; CriterionUpdateResponse\n</code></pre> <p>Update a single criterion or its metadata.</p> Source code in <code>components/api-service/src/api_service/main.py</code> <pre><code>@app.patch(\"/v1/criteria/{criterion_id}\")\ndef update_criterion(\n    criterion_id: str,\n    payload: Optional[CriterionUpdateRequest] = Body(default=None),\n    storage: Storage = Depends(get_storage),\n) -&gt; CriterionUpdateResponse:\n    \"\"\"Update a single criterion or its metadata.\"\"\"\n    updates = payload.model_dump(exclude_unset=True) if payload else {}\n    criterion = storage.update_criterion(\n        criterion_id=criterion_id,\n        text=updates.get(\"text\"),\n        criterion_type=updates.get(\"criterion_type\"),\n    )\n    if criterion is None:\n        raise HTTPException(status_code=404, detail=\"Criterion not found\")\n    return CriterionUpdateResponse(\n        criterion_id=criterion_id,\n        status=\"updated\",\n        criterion=_criterion_to_response(criterion),\n    )\n</code></pre>"},{"location":"api-service/docs/api/#api_service.main.ground_criterion","title":"ground_criterion","text":"<pre><code>ground_criterion(criterion_id: str, storage: Storage = Depends(get_storage)) -&gt; GroundingResponse\n</code></pre> <p>Retrieve SNOMED candidates and field mappings for a criterion.</p> Source code in <code>components/api-service/src/api_service/main.py</code> <pre><code>@app.post(\"/v1/criteria/{criterion_id}/ground\")\ndef ground_criterion(\n    criterion_id: str,\n    storage: Storage = Depends(get_storage),\n) -&gt; GroundingResponse:\n    \"\"\"Retrieve SNOMED candidates and field mappings for a criterion.\"\"\"\n    criterion = storage.get_criterion(criterion_id)\n    if criterion is None:\n        raise HTTPException(status_code=404, detail=\"Criterion not found\")\n\n    client = ubkg_client.UbkgClient()\n    candidates = client.search_snomed(criterion.text)\n    field_mappings = ubkg_client.propose_field_mapping(criterion.text)\n\n    snomed_codes = [candidate.code for candidate in candidates]\n    storage.set_snomed_codes(\n        criterion_id=criterion_id,\n        snomed_codes=snomed_codes,\n    )\n\n    response_candidates = [\n        GroundingCandidateResponse(\n            code=candidate.code,\n            display=candidate.display,\n            confidence=candidate.confidence,\n        )\n        for candidate in candidates\n    ]\n\n    field_mapping = None\n    if field_mappings:\n        suggestion = field_mappings[0]\n        field_mapping = FieldMappingResponse(\n            field=suggestion.field,\n            relation=suggestion.relation,\n            value=suggestion.value,\n            confidence=suggestion.confidence,\n        )\n\n    return GroundingResponse(\n        criterion_id=criterion_id,\n        candidates=response_candidates,\n        field_mapping=field_mapping,\n    )\n</code></pre>"},{"location":"api-service/docs/api/#api_service.main.hitl_feedback","title":"hitl_feedback","text":"<pre><code>hitl_feedback(payload: HitlFeedbackRequest | None = None, storage: Storage = Depends(get_storage)) -&gt; dict[str, str]\n</code></pre> <p>Record HITL feedback for criteria, SNOMED candidates, and field mappings.</p> Source code in <code>components/api-service/src/api_service/main.py</code> <pre><code>@app.post(\"/v1/hitl/feedback\")\ndef hitl_feedback(\n    payload: HitlFeedbackRequest | None = None,\n    storage: Storage = Depends(get_storage),\n) -&gt; dict[str, str]:\n    \"\"\"Record HITL feedback for criteria, SNOMED candidates, and field mappings.\"\"\"\n    _ = storage\n    _ = payload\n    return {\"status\": \"recorded\"}\n</code></pre>"},{"location":"api-service/docs/api/#api_service.storage","title":"storage","text":"<p>Storage layer for the API service.</p>"},{"location":"api-service/docs/api/#api_service.storage-classes","title":"Classes","text":""},{"location":"api-service/docs/api/#api_service.storage.ExtractedCriterion","title":"ExtractedCriterion","text":"<p>               Bases: <code>Protocol</code></p> <pre><code>\n              flowchart TD\n              api_service.storage.ExtractedCriterion[ExtractedCriterion]\n\n              \n\n              click api_service.storage.ExtractedCriterion href \"\" \"api_service.storage.ExtractedCriterion\"\n            </code></pre> <p>Protocol for extracted criteria returned by the pipeline.</p>"},{"location":"api-service/docs/api/#api_service.storage.Protocol","title":"Protocol","text":"<p>               Bases: <code>SQLModel</code></p> <pre><code>\n              flowchart TD\n              api_service.storage.Protocol[Protocol]\n\n              \n\n              click api_service.storage.Protocol href \"\" \"api_service.storage.Protocol\"\n            </code></pre> <p>Protocol record persisted for API requests.</p>"},{"location":"api-service/docs/api/#api_service.storage.Criterion","title":"Criterion","text":"<p>               Bases: <code>SQLModel</code></p> <pre><code>\n              flowchart TD\n              api_service.storage.Criterion[Criterion]\n\n              \n\n              click api_service.storage.Criterion href \"\" \"api_service.storage.Criterion\"\n            </code></pre> <p>Criterion record persisted for API requests.</p>"},{"location":"api-service/docs/api/#api_service.storage.HitlEdit","title":"HitlEdit","text":"<p>               Bases: <code>SQLModel</code></p> <pre><code>\n              flowchart TD\n              api_service.storage.HitlEdit[HitlEdit]\n\n              \n\n              click api_service.storage.HitlEdit href \"\" \"api_service.storage.HitlEdit\"\n            </code></pre> <p>HITL edit record for tracking reviewer changes.</p>"},{"location":"api-service/docs/api/#api_service.storage.IdCounter","title":"IdCounter","text":"<p>               Bases: <code>SQLModel</code></p> <pre><code>\n              flowchart TD\n              api_service.storage.IdCounter[IdCounter]\n\n              \n\n              click api_service.storage.IdCounter href \"\" \"api_service.storage.IdCounter\"\n            </code></pre> <p>Simple counter table for stable prefixed identifiers.</p>"},{"location":"api-service/docs/api/#api_service.storage.Storage","title":"Storage","text":"<pre><code>Storage(engine: Engine)\n</code></pre> <p>Repository wrapper around SQLModel sessions.</p> <p>Initialize the storage with a database engine.</p> Source code in <code>components/api-service/src/api_service/storage.py</code> <pre><code>def __init__(self, engine: Engine) -&gt; None:\n    \"\"\"Initialize the storage with a database engine.\"\"\"\n    self._engine = engine\n</code></pre> Functions create_protocol <pre><code>create_protocol(*, title: str, document_text: str, nct_id: str | None = None, condition: str | None = None, phase: str | None = None, source: str | None = None) -&gt; Protocol\n</code></pre> <p>Persist a protocol record and return it.</p> Source code in <code>components/api-service/src/api_service/storage.py</code> <pre><code>def create_protocol(\n    self,\n    *,\n    title: str,\n    document_text: str,\n    nct_id: str | None = None,\n    condition: str | None = None,\n    phase: str | None = None,\n    source: str | None = None,\n) -&gt; Protocol:\n    \"\"\"Persist a protocol record and return it.\"\"\"\n    with Session(self._engine) as session:\n        protocol_id = _next_id(session, \"protocol\", \"proto\")\n        protocol = Protocol(\n            id=protocol_id,\n            title=title.strip(),\n            document_text=document_text,\n            nct_id=_norm_opt(nct_id),\n            condition=_norm_opt(condition),\n            phase=_norm_opt(phase),\n            source=_norm_opt(source),\n        )\n        session.add(protocol)\n        session.commit()\n        session.refresh(protocol)\n        return protocol\n</code></pre> get_protocol <pre><code>get_protocol(protocol_id: str) -&gt; Protocol | None\n</code></pre> <p>Fetch a protocol by ID.</p> Source code in <code>components/api-service/src/api_service/storage.py</code> <pre><code>def get_protocol(self, protocol_id: str) -&gt; Protocol | None:\n    \"\"\"Fetch a protocol by ID.\"\"\"\n    with Session(self._engine) as session:\n        return session.get(Protocol, protocol_id)\n</code></pre> list_criteria <pre><code>list_criteria(protocol_id: str) -&gt; list[Criterion]\n</code></pre> <p>List criteria for a protocol.</p> Source code in <code>components/api-service/src/api_service/storage.py</code> <pre><code>def list_criteria(self, protocol_id: str) -&gt; list[Criterion]:\n    \"\"\"List criteria for a protocol.\"\"\"\n    with Session(self._engine) as session:\n        # Keep full models for simplicity; revisit partial selects if needed later.\n        statement = (\n            select(Criterion)\n            .where(cast(Any, Criterion.protocol_id) == protocol_id)\n            .order_by(Criterion.id)\n        )\n        return list(session.exec(statement))\n</code></pre> replace_criteria <pre><code>replace_criteria(*, protocol_id: str, extracted: Iterable[ExtractedCriterion]) -&gt; list[Criterion]\n</code></pre> <p>Replace criteria for a protocol with extracted entries.</p> Source code in <code>components/api-service/src/api_service/storage.py</code> <pre><code>def replace_criteria(\n    self, *, protocol_id: str, extracted: Iterable[ExtractedCriterion]\n) -&gt; list[Criterion]:\n    \"\"\"Replace criteria for a protocol with extracted entries.\"\"\"\n    with Session(self._engine) as session:\n        session.exec(\n            delete(Criterion).where(cast(Any, Criterion.protocol_id) == protocol_id)\n        )\n        stored: list[Criterion] = []\n        for item in extracted:\n            criterion_id = _next_id(session, \"criterion\", \"crit\")\n            criterion = Criterion(\n                id=criterion_id,\n                protocol_id=protocol_id,\n                text=item.text,\n                criterion_type=item.criterion_type,\n                confidence=item.confidence,\n                snomed_codes=[],\n            )\n            session.add(criterion)\n            stored.append(criterion)\n        session.commit()\n        return stored\n</code></pre> update_criterion <pre><code>update_criterion(*, criterion_id: str, text: str | None, criterion_type: str | None) -&gt; Criterion | None\n</code></pre> <p>Update a criterion's text/type and return the updated row.</p> Source code in <code>components/api-service/src/api_service/storage.py</code> <pre><code>def update_criterion(\n    self,\n    *,\n    criterion_id: str,\n    text: str | None,\n    criterion_type: str | None,\n) -&gt; Criterion | None:\n    \"\"\"Update a criterion's text/type and return the updated row.\"\"\"\n    with Session(self._engine) as session:\n        criterion = session.get(Criterion, criterion_id)\n        if criterion is None:\n            return None\n        if text is not None:\n            criterion.text = text\n        if criterion_type is not None:\n            criterion.criterion_type = criterion_type\n        session.add(criterion)\n        session.commit()\n        session.refresh(criterion)\n        return criterion\n</code></pre> get_criterion <pre><code>get_criterion(criterion_id: str) -&gt; Criterion | None\n</code></pre> <p>Fetch a criterion by ID.</p> Source code in <code>components/api-service/src/api_service/storage.py</code> <pre><code>def get_criterion(self, criterion_id: str) -&gt; Criterion | None:\n    \"\"\"Fetch a criterion by ID.\"\"\"\n    with Session(self._engine) as session:\n        return session.get(Criterion, criterion_id)\n</code></pre> set_snomed_codes <pre><code>set_snomed_codes(*, criterion_id: str, snomed_codes: list[str]) -&gt; Criterion | None\n</code></pre> <p>Set SNOMED codes for a criterion.</p> Source code in <code>components/api-service/src/api_service/storage.py</code> <pre><code>def set_snomed_codes(\n    self, *, criterion_id: str, snomed_codes: list[str]\n) -&gt; Criterion | None:\n    \"\"\"Set SNOMED codes for a criterion.\"\"\"\n    with Session(self._engine) as session:\n        criterion = session.get(Criterion, criterion_id)\n        if criterion is None:\n            return None\n        criterion.snomed_codes = snomed_codes\n        session.add(criterion)\n        session.commit()\n        session.refresh(criterion)\n        return criterion\n</code></pre> create_hitl_edit <pre><code>create_hitl_edit(*, criterion_id: str, action: str, snomed_code_added: str | None = None, snomed_code_removed: str | None = None, field_mapping_added: str | None = None, field_mapping_removed: str | None = None, note: str | None = None) -&gt; HitlEdit\n</code></pre> <p>Persist a HITL edit record.</p> Source code in <code>components/api-service/src/api_service/storage.py</code> <pre><code>def create_hitl_edit(\n    self,\n    *,\n    criterion_id: str,\n    action: str,\n    snomed_code_added: str | None = None,\n    snomed_code_removed: str | None = None,\n    field_mapping_added: str | None = None,\n    field_mapping_removed: str | None = None,\n    note: str | None = None,\n) -&gt; HitlEdit:\n    \"\"\"Persist a HITL edit record.\"\"\"\n    with Session(self._engine) as session:\n        edit_id = _next_id(session, \"hitl_edit\", \"edit\")\n        edit = HitlEdit(\n            id=edit_id,\n            criterion_id=criterion_id,\n            action=action,\n            snomed_code_added=snomed_code_added,\n            snomed_code_removed=snomed_code_removed,\n            field_mapping_added=field_mapping_added,\n            field_mapping_removed=field_mapping_removed,\n            note=note,\n        )\n        session.add(edit)\n        session.commit()\n        session.refresh(edit)\n        return edit\n</code></pre> list_hitl_edits <pre><code>list_hitl_edits(criterion_id: str) -&gt; list[HitlEdit]\n</code></pre> <p>List all HITL edits for a criterion.</p> Source code in <code>components/api-service/src/api_service/storage.py</code> <pre><code>def list_hitl_edits(self, criterion_id: str) -&gt; list[HitlEdit]:\n    \"\"\"List all HITL edits for a criterion.\"\"\"\n    with Session(self._engine) as session:\n        statement = (\n            select(HitlEdit)\n            .where(cast(Any, HitlEdit.criterion_id) == criterion_id)\n            .order_by(cast(Any, HitlEdit.created_at))\n        )\n        return list(session.exec(statement))\n</code></pre>"},{"location":"api-service/docs/api/#api_service.storage-functions","title":"Functions","text":""},{"location":"api-service/docs/api/#api_service.storage.get_engine","title":"get_engine  <code>cached</code>","text":"<pre><code>get_engine() -&gt; Engine\n</code></pre> <p>Create or return the cached database engine.</p> Source code in <code>components/api-service/src/api_service/storage.py</code> <pre><code>@lru_cache\ndef get_engine() -&gt; Engine:\n    \"\"\"Create or return the cached database engine.\"\"\"\n    db_path = DEFAULT_DB_PATH\n    if \"API_SERVICE_DB_URL\" not in os.environ:\n        db_path.parent.mkdir(parents=True, exist_ok=True)\n    return create_engine(\n        _database_url(),\n        connect_args={\"check_same_thread\": False},\n    )\n</code></pre>"},{"location":"api-service/docs/api/#api_service.storage.init_db","title":"init_db","text":"<pre><code>init_db() -&gt; None\n</code></pre> <p>Initialize the database tables.</p> Source code in <code>components/api-service/src/api_service/storage.py</code> <pre><code>def init_db() -&gt; None:\n    \"\"\"Initialize the database tables.\"\"\"\n    SQLModel.metadata.create_all(get_engine())\n</code></pre>"},{"location":"api-service/docs/api/#api_service.storage.reset_storage","title":"reset_storage","text":"<pre><code>reset_storage() -&gt; None\n</code></pre> <p>Clear all stored data (used for tests and demos).</p> Source code in <code>components/api-service/src/api_service/storage.py</code> <pre><code>def reset_storage() -&gt; None:\n    \"\"\"Clear all stored data (used for tests and demos).\"\"\"\n    engine = get_engine()\n    SQLModel.metadata.drop_all(engine)\n    SQLModel.metadata.create_all(engine)\n    init_db()\n</code></pre>"},{"location":"data-pipeline/","title":"data-pipeline","text":"<p>Protocol ingestion tools for ClinicalTrials.gov. Converts raw protocol documents into normalized records.</p>"},{"location":"data-pipeline/#responsibilities","title":"Responsibilities","text":"<ul> <li>Download or ingest protocol text/PDFs.</li> <li>Normalize and store protocol metadata.</li> <li>Emit data for extraction and grounding.</li> </ul>"},{"location":"data-pipeline/#protocol-download","title":"Protocol Download","text":"<p>To download protocol PDFs from multiple sources (DAC, ClinicalTrials.gov, BMJ Open, JMIR), use the protocol download script in the root <code>scripts/</code> directory:</p> <pre><code># From repository root\npython scripts/download_protocol_sources.py\n\n# With options\npython scripts/download_protocol_sources.py --sources dac jmir --max-per-source 20\n</code></pre> <p>See the main Getting Started documentation for full usage details.</p>"},{"location":"data-pipeline/#entry-point","title":"Entry Point","text":"<ul> <li><code>data_pipeline/download_protocols.py</code></li> </ul>"},{"location":"data-pipeline/#running-the-stub","title":"Running the Stub","text":"<pre><code>uv run python -m data_pipeline.download_protocols\n</code></pre>"},{"location":"data-pipeline/#planned-outputs","title":"Planned Outputs","text":"<ul> <li><code>protocols</code> table rows (<code>nct_id</code>, title, condition, phase).</li> <li><code>documents</code> table rows for protocol text.</li> </ul>"},{"location":"data-pipeline/docs/api/","title":"data-pipeline API Reference","text":"<p>This page contains automatically generated API documentation for the data-pipeline component.</p>"},{"location":"data-pipeline/docs/api/#api-documentation","title":"API Documentation","text":""},{"location":"data-pipeline/docs/api/#data_pipeline","title":"data_pipeline","text":"<p>data-pipeline package.</p>"},{"location":"data-pipeline/docs/api/#data_pipeline-modules","title":"Modules","text":""},{"location":"data-pipeline/docs/api/#data_pipeline.download_protocols","title":"download_protocols","text":"<p>Download protocols and emit normalized records.</p>"},{"location":"data-pipeline/docs/api/#data_pipeline.download_protocols-classes","title":"Classes","text":""},{"location":"data-pipeline/docs/api/#data_pipeline.download_protocols.ProtocolRecord","title":"ProtocolRecord  <code>dataclass</code>","text":"<pre><code>ProtocolRecord(nct_id: str, title: str, condition: str, phase: str, document_text: str, source: str | None = None, registry_id: str | None = None, registry_type: str | None = None)\n</code></pre> <p>Normalized protocol record for downstream services.</p> <p>Parameters:</p> Name Type Description Default <code>nct_id</code> <code>str</code> <p>ClinicalTrials.gov identifier.</p> required <code>title</code> <code>str</code> <p>Trial title.</p> required <code>condition</code> <code>str</code> <p>Primary condition or disease area.</p> required <code>phase</code> <code>str</code> <p>Trial phase label.</p> required <code>document_text</code> <code>str</code> <p>Extracted protocol text for NLP processing.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; ProtocolRecord(\n...     nct_id=\"NCT00000000\",\n...     title=\"Example Trial\",\n...     condition=\"Melanoma\",\n...     phase=\"Phase 2\",\n...     document_text=\"Inclusion: Age &gt;= 18.\",\n... )\nProtocolRecord(\n...     nct_id='NCT00000000',\n...     title='Example Trial',\n...     condition='Melanoma',\n...     phase='Phase 2',\n...     document_text='Inclusion: Age &gt;= 18.',\n... )\n</code></pre> Notes <p>This model represents the canonical ingestion output for the API service.</p>"},{"location":"data-pipeline/docs/api/#data_pipeline.download_protocols-functions","title":"Functions","text":""},{"location":"data-pipeline/docs/api/#data_pipeline.download_protocols.fetch_from_clinicaltrials","title":"fetch_from_clinicaltrials","text":"<pre><code>fetch_from_clinicaltrials(query: str, limit: int = 50) -&gt; List[ProtocolRecord]\n</code></pre> <p>Fetch protocols from ClinicalTrials.gov API v2.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Condition or keyword to search.</p> required <code>limit</code> <code>int</code> <p>Maximum records to fetch.</p> <code>50</code> <p>Returns:</p> Type Description <code>List[ProtocolRecord]</code> <p>List of normalized protocol records.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If limit is not positive.</p> Source code in <code>components/data-pipeline/src/data_pipeline/download_protocols.py</code> <pre><code>def fetch_from_clinicaltrials(query: str, limit: int = 50) -&gt; List[ProtocolRecord]:\n    \"\"\"Fetch protocols from ClinicalTrials.gov API v2.\n\n    Args:\n        query: Condition or keyword to search.\n        limit: Maximum records to fetch.\n\n    Returns:\n        List of normalized protocol records.\n\n    Raises:\n        ValueError: If limit is not positive.\n    \"\"\"\n    if limit &lt;= 0:\n        raise ValueError(\"limit must be positive\")\n\n    page_size = min(limit, 100)\n    params: dict[str, str | int] = {\n        \"query.cond\": query,\n        \"fields\": \"NCTId|BriefTitle|Condition|Phase|EligibilityModule\",\n        \"pageSize\": page_size,\n        \"format\": \"json\",\n    }\n\n    records: List[ProtocolRecord] = []\n    next_token: str | None = None\n    while len(records) &lt; limit:\n        if next_token:\n            params[\"pageToken\"] = next_token\n        else:\n            params.pop(\"pageToken\", None)\n\n        resp = httpx.get(CT_API_BASE, params=params, timeout=30)\n        resp.raise_for_status()\n        payload = resp.json()\n\n        for study in payload.get(\"studies\", []):\n            proto = study.get(\"protocolSection\", {})\n            ident = proto.get(\"identificationModule\", {})\n            conds = proto.get(\"conditionsModule\", {})\n            design = proto.get(\"designModule\", {})\n            elig = proto.get(\"eligibilityModule\", {})\n\n            records.append(\n                ProtocolRecord(\n                    nct_id=ident.get(\"nctId\", \"\"),\n                    title=ident.get(\"briefTitle\", \"\"),\n                    condition=(conds.get(\"conditions\") or [\"\"])[0],\n                    phase=(design.get(\"phases\") or [\"\"])[0],\n                    document_text=elig.get(\"eligibilityCriteria\", \"\"),\n                )\n            )\n            if len(records) &gt;= limit:\n                break\n\n        next_token = payload.get(\"nextPageToken\")\n        if not next_token:\n            break\n\n    return records\n</code></pre>"},{"location":"data-pipeline/docs/api/#data_pipeline.download_protocols.extract_text_from_pdf","title":"extract_text_from_pdf","text":"<pre><code>extract_text_from_pdf(path: Path) -&gt; str\n</code></pre> <p>Extract text from a PDF file using pypdf.</p> Source code in <code>components/data-pipeline/src/data_pipeline/download_protocols.py</code> <pre><code>def extract_text_from_pdf(path: Path) -&gt; str:\n    \"\"\"Extract text from a PDF file using pypdf.\"\"\"\n    reader = PdfReader(str(path))\n    chunks: list[str] = []\n    for page in reader.pages:\n        page_text = page.extract_text() or \"\"\n        if page_text:\n            chunks.append(page_text)\n    return \"\\n\".join(chunks).strip()\n</code></pre>"},{"location":"data-pipeline/docs/api/#data_pipeline.download_protocols.ingest_local_protocols","title":"ingest_local_protocols","text":"<pre><code>ingest_local_protocols(manifest_path: Path = DEFAULT_MANIFEST_PATH, limit: int = 50) -&gt; List[ProtocolRecord]\n</code></pre> <p>Load protocol PDFs referenced in a manifest and extract document text.</p> Source code in <code>components/data-pipeline/src/data_pipeline/download_protocols.py</code> <pre><code>def ingest_local_protocols(\n    manifest_path: Path = DEFAULT_MANIFEST_PATH, limit: int = 50\n) -&gt; List[ProtocolRecord]:\n    \"\"\"Load protocol PDFs referenced in a manifest and extract document text.\"\"\"\n    if limit &lt;= 0:\n        raise ValueError(\"limit must be positive\")\n    if not manifest_path.exists():\n        raise FileNotFoundError(f\"Manifest not found: {manifest_path}\")\n\n    records: list[ProtocolRecord] = []\n    for entry in _iter_manifest_entries(manifest_path):\n        if len(records) &gt;= limit:\n            break\n        record = _build_record_from_entry(entry)\n        if record is not None:\n            records.append(record)\n    return records\n</code></pre>"},{"location":"data-pipeline/docs/api/#data_pipeline.download_protocols.emit_records","title":"emit_records","text":"<pre><code>emit_records(records: List[ProtocolRecord], output_path: Path | None = None) -&gt; None\n</code></pre> <p>Write protocol records to JSONL file.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>List[ProtocolRecord]</code> <p>Protocol records to emit.</p> required <code>output_path</code> <code>Path | None</code> <p>Output file path. If None, prints to stdout.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>components/data-pipeline/src/data_pipeline/download_protocols.py</code> <pre><code>def emit_records(\n    records: List[ProtocolRecord], output_path: Path | None = None\n) -&gt; None:\n    \"\"\"Write protocol records to JSONL file.\n\n    Args:\n        records: Protocol records to emit.\n        output_path: Output file path. If None, prints to stdout.\n\n    Returns:\n        None.\n    \"\"\"\n    lines = [json.dumps(asdict(record)) for record in records]\n\n    if output_path:\n        try:\n            output_path.parent.mkdir(parents=True, exist_ok=True)\n            output_path.write_text(\"\\n\".join(lines) + \"\\n\")\n        except OSError as exc:\n            message = f\"Failed to write output to {output_path}: {exc}\"\n            raise RuntimeError(message) from exc\n    else:\n        for line in lines:\n            print(line)\n</code></pre>"},{"location":"data-pipeline/docs/api/#data_pipeline.download_protocols.main","title":"main","text":"<pre><code>main() -&gt; None\n</code></pre> <p>CLI entrypoint.</p> Source code in <code>components/data-pipeline/src/data_pipeline/download_protocols.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"CLI entrypoint.\"\"\"\n    import argparse\n\n    parser = argparse.ArgumentParser(\n        description=\"Download protocols from ClinicalTrials.gov or local PDFs\"\n    )\n    parser.add_argument(\"--query\", default=\"oncology\", help=\"Search condition\")\n    parser.add_argument(\"--limit\", type=int, default=50, help=\"Max records\")\n    parser.add_argument(\n        \"--local\",\n        action=\"store_true\",\n        help=\"Ingest protocols from local PDFs using the manifest.jsonl\",\n    )\n    parser.add_argument(\n        \"--manifest-path\",\n        type=Path,\n        default=DEFAULT_MANIFEST_PATH,\n        help=\"Path to manifest.jsonl for local ingestion\",\n    )\n    parser.add_argument(\"--output\", type=Path, help=\"Output JSONL path\")\n    args = parser.parse_args()\n\n    if args.local:\n        records = ingest_local_protocols(args.manifest_path, args.limit)\n    else:\n        records = fetch_from_clinicaltrials(args.query, args.limit)\n    emit_records(records, args.output)\n    print(f\"Downloaded {len(records)} protocols\")\n</code></pre>"},{"location":"diagrams/grounding-flow/","title":"Grounding Flow","text":"<pre><code>flowchart LR\n  criterion[CriterionText] --&gt; ubkg[UBKGSearch]\n  ubkg --&gt; candidates[SNOMEDCandidates]\n  candidates --&gt; rank[ModelRanking]\n  rank --&gt; review[HITLReview]\n  criterion --&gt; fieldmap[FieldRelationValueMapping]\n  fieldmap --&gt; review\n</code></pre>"},{"location":"diagrams/hitl-flow/","title":"HITL Flow","text":"<pre><code>flowchart LR\n  protocol[ProtocolUpload] --&gt; extract[CriteriaExtraction]\n  extract --&gt; ground[UBKGGrounding + FieldMapping]\n  ground --&gt; review[HITLReview]\n  review --&gt; feedback[FeedbackLog]\n  feedback --&gt; retrain[LoRAUpdate]\n</code></pre>"},{"location":"evaluation/","title":"evaluation","text":"<p>Metrics and reporting for extraction, grounding, and field/relation/value mapping quality.</p>"},{"location":"evaluation/#responsibilities","title":"Responsibilities","text":"<ul> <li>Compute extraction F1, SNOMED Top-1 accuracy, and field/relation/value mapping quality.</li> <li>Aggregate HITL acceptance metrics.</li> </ul>"},{"location":"evaluation/#key-module","title":"Key Module","text":"<ul> <li><code>evaluation/metrics.py</code></li> </ul>"},{"location":"evaluation/#example-usage","title":"Example Usage","text":"<pre><code>from evaluation.metrics import extraction_f1, snomed_top1_accuracy\n\nf1 = extraction_f1([\"age &gt;= 18\"], [\"age &gt;= 18\"])\ntop1 = snomed_top1_accuracy([\"372244006\"], [\"372244006\"])\n</code></pre>"},{"location":"evaluation/#tests","title":"Tests","text":"<pre><code>make check-all\n</code></pre>"},{"location":"evaluation/docs/api/","title":"evaluation API Reference","text":"<p>This page contains automatically generated API documentation for the evaluation component.</p>"},{"location":"evaluation/docs/api/#api-documentation","title":"API Documentation","text":""},{"location":"evaluation/docs/api/#evaluation","title":"evaluation","text":"<p>evaluation package.</p>"},{"location":"evaluation/docs/api/#evaluation-modules","title":"Modules","text":""},{"location":"evaluation/docs/api/#evaluation.metrics","title":"metrics","text":"<p>Evaluation metrics stubs.</p>"},{"location":"evaluation/docs/api/#evaluation.metrics-functions","title":"Functions","text":""},{"location":"evaluation/docs/api/#evaluation.metrics.extraction_f1","title":"extraction_f1","text":"<pre><code>extraction_f1(predicted: List[str], gold: List[str]) -&gt; float\n</code></pre> <p>Compute extraction F1 score for criteria lists.</p> <p>Parameters:</p> Name Type Description Default <code>predicted</code> <code>List[str]</code> <p>Extracted criterion strings.</p> required <code>gold</code> <code>List[str]</code> <p>Gold-standard criterion strings.</p> required <p>Returns:</p> Type Description <code>float</code> <p>F1 score in the range [0.0, 1.0].</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the inputs are empty or not comparable.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; extraction_f1([\"age &gt;= 18\"], [\"age &gt;= 18\"])\n0.0\n</code></pre> Notes <p>This is a wireframe stub. The production implementation will normalize text and compute precision/recall on span matches.</p> Source code in <code>components/evaluation/src/evaluation/metrics.py</code> <pre><code>def extraction_f1(predicted: List[str], gold: List[str]) -&gt; float:\n    \"\"\"Compute extraction F1 score for criteria lists.\n\n    Args:\n        predicted: Extracted criterion strings.\n        gold: Gold-standard criterion strings.\n\n    Returns:\n        F1 score in the range [0.0, 1.0].\n\n    Raises:\n        ValueError: If the inputs are empty or not comparable.\n\n    Examples:\n        &gt;&gt;&gt; extraction_f1([\"age &gt;= 18\"], [\"age &gt;= 18\"])\n        0.0\n\n    Notes:\n        This is a wireframe stub. The production implementation will\n        normalize text and compute precision/recall on span matches.\n    \"\"\"\n    if not predicted or not gold:\n        raise ValueError(\"predicted and gold must be non-empty\")\n\n    predicted_set = set(predicted)\n    gold_set = set(gold)\n    true_positives = len(predicted_set &amp; gold_set)\n    precision = true_positives / len(predicted_set)\n    recall = true_positives / len(gold_set)\n    if precision + recall == 0:\n        return 0.0\n    return 2 * precision * recall / (precision + recall)\n</code></pre>"},{"location":"evaluation/docs/api/#evaluation.metrics.snomed_top1_accuracy","title":"snomed_top1_accuracy","text":"<pre><code>snomed_top1_accuracy(predicted: List[str], gold: List[str]) -&gt; float\n</code></pre> <p>Compute Top-1 accuracy for SNOMED grounding.</p> <p>Parameters:</p> Name Type Description Default <code>predicted</code> <code>List[str]</code> <p>Predicted SNOMED codes.</p> required <code>gold</code> <code>List[str]</code> <p>Gold-standard SNOMED codes.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Top-1 accuracy in the range [0.0, 1.0].</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the inputs are empty or not comparable.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; snomed_top1_accuracy([\"372244006\"], [\"372244006\"])\n0.0\n</code></pre> Notes <p>This stub will be replaced by a metric implementation aligned with UBKG candidate ranking outputs.</p> Source code in <code>components/evaluation/src/evaluation/metrics.py</code> <pre><code>def snomed_top1_accuracy(predicted: List[str], gold: List[str]) -&gt; float:\n    \"\"\"Compute Top-1 accuracy for SNOMED grounding.\n\n    Args:\n        predicted: Predicted SNOMED codes.\n        gold: Gold-standard SNOMED codes.\n\n    Returns:\n        Top-1 accuracy in the range [0.0, 1.0].\n\n    Raises:\n        ValueError: If the inputs are empty or not comparable.\n\n    Examples:\n        &gt;&gt;&gt; snomed_top1_accuracy([\"372244006\"], [\"372244006\"])\n        0.0\n\n    Notes:\n        This stub will be replaced by a metric implementation aligned with\n        UBKG candidate ranking outputs.\n    \"\"\"\n    if not predicted or not gold:\n        raise ValueError(\"predicted and gold must be non-empty\")\n\n    comparisons = zip(predicted, gold)\n    matches = sum(\n        1\n        for predicted_code, gold_code in comparisons\n        if predicted_code == gold_code\n    )\n    return matches / len(gold)\n</code></pre>"},{"location":"evaluation/docs/api/#evaluation.metrics.field_mapping_accuracy","title":"field_mapping_accuracy","text":"<pre><code>field_mapping_accuracy(predicted: List[str], gold: List[str]) -&gt; float\n</code></pre> <p>Compute accuracy for field/relation/value mappings.</p> <p>Parameters:</p> Name Type Description Default <code>predicted</code> <code>List[str]</code> <p>Predicted normalized mapping strings (field|relation|value).</p> required <code>gold</code> <code>List[str]</code> <p>Gold-standard normalized mapping strings.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Accuracy in the range [0.0, 1.0].</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the inputs are empty or not comparable.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; field_mapping_accuracy([\"demographics.age|&gt;|75\"], [\"demographics.age|&gt;|75\"])\n0.0\n</code></pre> Notes <p>This stub will be replaced by a metric implementation aligned with normalized field/value parsing in the grounding service.</p> Source code in <code>components/evaluation/src/evaluation/metrics.py</code> <pre><code>def field_mapping_accuracy(predicted: List[str], gold: List[str]) -&gt; float:\n    \"\"\"Compute accuracy for field/relation/value mappings.\n\n    Args:\n        predicted: Predicted normalized mapping strings (field|relation|value).\n        gold: Gold-standard normalized mapping strings.\n\n    Returns:\n        Accuracy in the range [0.0, 1.0].\n\n    Raises:\n        ValueError: If the inputs are empty or not comparable.\n\n    Examples:\n        &gt;&gt;&gt; field_mapping_accuracy([\"demographics.age|&gt;|75\"], [\"demographics.age|&gt;|75\"])\n        0.0\n\n    Notes:\n        This stub will be replaced by a metric implementation aligned with\n        normalized field/value parsing in the grounding service.\n    \"\"\"\n    if not predicted or not gold:\n        raise ValueError(\"predicted and gold must be non-empty\")\n\n    comparisons = zip(predicted, gold)\n    matches = sum(\n        1\n        for predicted_value, gold_value in comparisons\n        if predicted_value == gold_value\n    )\n    return matches / len(gold)\n</code></pre>"},{"location":"evaluation/docs/api/#evaluation.metrics.hitl_acceptance_rate","title":"hitl_acceptance_rate","text":"<pre><code>hitl_acceptance_rate(actions: Iterable[str]) -&gt; float\n</code></pre> <p>Compute acceptance rate from HITL action labels.</p> <p>Parameters:</p> Name Type Description Default <code>actions</code> <code>Iterable[str]</code> <p>Iterable of action labels (e.g., \"accept\", \"reject\").</p> required <p>Returns:</p> Type Description <code>float</code> <p>Acceptance rate as a float in the range [0.0, 1.0].</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no actions are provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; hitl_acceptance_rate([\"accept\", \"reject\", \"accept\"])\n0.0\n</code></pre> Notes <p>This stub represents the acceptance metric tracked in the hackathon.</p> Source code in <code>components/evaluation/src/evaluation/metrics.py</code> <pre><code>def hitl_acceptance_rate(actions: Iterable[str]) -&gt; float:\n    \"\"\"Compute acceptance rate from HITL action labels.\n\n    Args:\n        actions: Iterable of action labels (e.g., \"accept\", \"reject\").\n\n    Returns:\n        Acceptance rate as a float in the range [0.0, 1.0].\n\n    Raises:\n        ValueError: If no actions are provided.\n\n    Examples:\n        &gt;&gt;&gt; hitl_acceptance_rate([\"accept\", \"reject\", \"accept\"])\n        0.0\n\n    Notes:\n        This stub represents the acceptance metric tracked in the hackathon.\n    \"\"\"\n    action_list = list(actions)\n    if not action_list:\n        raise ValueError(\"actions must be non-empty\")\n\n    accepted = sum(1 for action in action_list if action == \"accept\")\n    return accepted / len(action_list)\n</code></pre>"},{"location":"extraction-service/","title":"extraction-service","text":"<p>Wireframe extraction pipeline for MedGemma Task A. Produces atomic inclusion/exclusion criteria from protocol text.</p>"},{"location":"extraction-service/#responsibilities","title":"Responsibilities","text":"<ul> <li>Segment protocol text into candidate criteria.</li> <li>Classify criteria as inclusion/exclusion.</li> <li>Return evidence snippets and confidence scores.</li> </ul>"},{"location":"extraction-service/#key-module","title":"Key Module","text":"<ul> <li><code>extraction_service/pipeline.py</code></li> </ul>"},{"location":"extraction-service/#example-usage","title":"Example Usage","text":"<pre><code>from extraction_service.pipeline import extract_criteria\n\ncriteria = extract_criteria(\"Inclusion: Age &gt;= 18...\")\nfor item in criteria:\n    print(item.text, item.criterion_type, item.confidence)\n</code></pre>"},{"location":"extraction-service/#tests","title":"Tests","text":"<pre><code>make check-all\n</code></pre>"},{"location":"extraction-service/#notes","title":"Notes","text":"<p>This component is a stub. It documents the intended API for wiring MedGemma LoRA adapters.</p>"},{"location":"extraction-service/docs/api/","title":"extraction-service API Reference","text":"<p>This page contains automatically generated API documentation for the extraction-service component.</p>"},{"location":"extraction-service/docs/api/#api-documentation","title":"API Documentation","text":""},{"location":"extraction-service/docs/api/#extraction_service","title":"extraction_service","text":"<p>extraction-service package.</p>"},{"location":"extraction-service/docs/api/#extraction_service-modules","title":"Modules","text":""},{"location":"extraction-service/docs/api/#extraction_service.pipeline","title":"pipeline","text":"<p>Extraction pipeline stubs for MedGemma Task A.</p>"},{"location":"extraction-service/docs/api/#extraction_service.pipeline-classes","title":"Classes","text":""},{"location":"extraction-service/docs/api/#extraction_service.pipeline.Criterion","title":"Criterion  <code>dataclass</code>","text":"<pre><code>Criterion(text: str, criterion_type: str, confidence: float)\n</code></pre> <p>Atomic inclusion/exclusion criterion extracted from a protocol.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The criterion text span.</p> required <code>criterion_type</code> <code>str</code> <p>Inclusion or exclusion label.</p> required <code>confidence</code> <code>float</code> <p>Model confidence score from 0.0 to 1.0.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; Criterion(\n...     text=\"Age &gt;= 18 years\",\n...     criterion_type=\"inclusion\",\n...     confidence=0.92,\n... )\nCriterion(text='Age &gt;= 18 years', criterion_type='inclusion', confidence=0.92)\n</code></pre> Notes <p>Evidence spans, grounding candidates, and field mappings are stored downstream by the API.</p>"},{"location":"extraction-service/docs/api/#extraction_service.pipeline-functions","title":"Functions","text":""},{"location":"extraction-service/docs/api/#extraction_service.pipeline.extract_criteria","title":"extract_criteria","text":"<pre><code>extract_criteria(document_text: str) -&gt; List[Criterion]\n</code></pre> <p>Extract atomic inclusion/exclusion criteria from protocol text.</p> <p>Parameters:</p> Name Type Description Default <code>document_text</code> <code>str</code> <p>Raw protocol text or extracted PDF text.</p> required <p>Returns:</p> Type Description <code>List[Criterion]</code> <p>A list of extracted criteria with type and confidence scores.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the document text is empty or not parseable.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; extract_criteria(\"Inclusion: Age &gt;= 18 years.\")\n[]\n</code></pre> Notes <p>This is a wireframe stub. The production pipeline will use MedGemma for extraction and classification, with evidence spans attached.</p> Source code in <code>components/extraction-service/src/extraction_service/pipeline.py</code> <pre><code>def extract_criteria(document_text: str) -&gt; List[Criterion]:\n    \"\"\"Extract atomic inclusion/exclusion criteria from protocol text.\n\n    Args:\n        document_text: Raw protocol text or extracted PDF text.\n\n    Returns:\n        A list of extracted criteria with type and confidence scores.\n\n    Raises:\n        ValueError: If the document text is empty or not parseable.\n\n    Examples:\n        &gt;&gt;&gt; extract_criteria(\"Inclusion: Age &gt;= 18 years.\")\n        []\n\n    Notes:\n        This is a wireframe stub. The production pipeline will use MedGemma\n        for extraction and classification, with evidence spans attached.\n    \"\"\"\n    if not document_text.strip():\n        raise ValueError(\"document_text is required\")\n\n    criteria: List[Criterion] = []\n    for sentence in split_into_candidate_sentences(document_text):\n        criteria.append(\n            Criterion(\n                text=sentence,\n                criterion_type=classify_criterion_type(sentence),\n                confidence=0.9,\n            )\n        )\n    return criteria\n</code></pre>"},{"location":"extraction-service/docs/api/#extraction_service.pipeline.split_into_candidate_sentences","title":"split_into_candidate_sentences","text":"<pre><code>split_into_candidate_sentences(document_text: str) -&gt; List[str]\n</code></pre> <p>Split protocol text into candidate sentences for extraction.</p> <p>Parameters:</p> Name Type Description Default <code>document_text</code> <code>str</code> <p>Raw protocol text or extracted PDF text.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>Sentence-level candidates for criteria extraction.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input text is empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; split_into_candidate_sentences(\"Inclusion: Age &gt;= 18. Exclusion: Pregnant.\")\n[]\n</code></pre> Notes <p>Intended to be replaced by a robust section parser and sentence splitter tuned for clinical trial formatting.</p> Source code in <code>components/extraction-service/src/extraction_service/pipeline.py</code> <pre><code>def split_into_candidate_sentences(document_text: str) -&gt; List[str]:\n    \"\"\"Split protocol text into candidate sentences for extraction.\n\n    Args:\n        document_text: Raw protocol text or extracted PDF text.\n\n    Returns:\n        Sentence-level candidates for criteria extraction.\n\n    Raises:\n        ValueError: If the input text is empty.\n\n    Examples:\n        &gt;&gt;&gt; split_into_candidate_sentences(\"Inclusion: Age &gt;= 18. Exclusion: Pregnant.\")\n        []\n\n    Notes:\n        Intended to be replaced by a robust section parser and sentence\n        splitter tuned for clinical trial formatting.\n    \"\"\"\n    if not document_text.strip():\n        raise ValueError(\"document_text is required\")\n\n    normalized = document_text.replace(\"\\n\", \" \").strip()\n    raw_sentences = [segment.strip() for segment in normalized.split(\".\")]\n    candidates: List[str] = []\n    for sentence in raw_sentences:\n        if not sentence:\n            continue\n        lowered = sentence.lower()\n        if lowered.startswith(\"inclusion:\"):\n            sentence = sentence[len(\"inclusion:\") :].strip()\n        elif lowered.startswith(\"exclusion:\"):\n            sentence = sentence[len(\"exclusion:\") :].strip()\n        if sentence:\n            candidates.append(sentence)\n    return candidates\n</code></pre>"},{"location":"extraction-service/docs/api/#extraction_service.pipeline.classify_criterion_type","title":"classify_criterion_type","text":"<pre><code>classify_criterion_type(candidate_text: str) -&gt; str\n</code></pre> <p>Classify a criterion candidate as inclusion or exclusion.</p> <p>Parameters:</p> Name Type Description Default <code>candidate_text</code> <code>str</code> <p>Candidate sentence or span to classify.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Either <code>\"inclusion\"</code> or <code>\"exclusion\"</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the candidate text is empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; classify_criterion_type(\"Age &gt;= 18 years\")\n'inclusion'\n</code></pre> Notes <p>This stub is a placeholder for MedGemma classification.</p> Source code in <code>components/extraction-service/src/extraction_service/pipeline.py</code> <pre><code>def classify_criterion_type(candidate_text: str) -&gt; str:\n    \"\"\"Classify a criterion candidate as inclusion or exclusion.\n\n    Args:\n        candidate_text: Candidate sentence or span to classify.\n\n    Returns:\n        Either ``\"inclusion\"`` or ``\"exclusion\"``.\n\n    Raises:\n        ValueError: If the candidate text is empty.\n\n    Examples:\n        &gt;&gt;&gt; classify_criterion_type(\"Age &gt;= 18 years\")\n        'inclusion'\n\n    Notes:\n        This stub is a placeholder for MedGemma classification.\n    \"\"\"\n    if not candidate_text.strip():\n        raise ValueError(\"candidate_text is required\")\n\n    lowered = candidate_text.lower()\n    if \"exclusion\" in lowered or \"exclude\" in lowered or \"pregnant\" in lowered:\n        return \"exclusion\"\n    return \"inclusion\"\n</code></pre>"},{"location":"grounding-service/","title":"grounding-service","text":"<p>UBKG REST client and grounding helpers for Task B. Retrieves SNOMED candidates and field/relation/value mappings for each criterion.</p>"},{"location":"grounding-service/#responsibilities","title":"Responsibilities","text":"<ul> <li>Query UBKG for SNOMED candidates.</li> <li>Propose field/relation/value mappings for screening.</li> <li>Return ranked candidates with display names and confidence scores.</li> </ul>"},{"location":"grounding-service/#key-module","title":"Key Module","text":"<ul> <li><code>grounding_service/ubkg_client.py</code></li> </ul>"},{"location":"grounding-service/#example-usage","title":"Example Usage","text":"<pre><code>from grounding_service.ubkg_client import UbkgClient\n\nclient = UbkgClient()\nresults = client.search_snomed(\"stage III melanoma\")\nprint(results)\n</code></pre>"},{"location":"grounding-service/#tests","title":"Tests","text":"<pre><code>make check-all\n</code></pre>"},{"location":"grounding-service/#configuration-planned","title":"Configuration (planned)","text":"<ul> <li><code>UBKG_BASE_URL</code> (default: <code>https://ubkg-api.xconsortia.org</code>)</li> <li><code>UBKG_TIMEOUT_SECONDS</code></li> </ul>"},{"location":"grounding-service/docs/api/","title":"grounding-service API Reference","text":"<p>This page contains automatically generated API documentation for the grounding-service component.</p>"},{"location":"grounding-service/docs/api/#api-documentation","title":"API Documentation","text":""},{"location":"grounding-service/docs/api/#grounding_service","title":"grounding_service","text":"<p>grounding-service package.</p>"},{"location":"grounding-service/docs/api/#grounding_service-modules","title":"Modules","text":""},{"location":"grounding-service/docs/api/#grounding_service.ubkg_client","title":"ubkg_client","text":"<p>UBKG REST client stub.</p>"},{"location":"grounding-service/docs/api/#grounding_service.ubkg_client-classes","title":"Classes","text":""},{"location":"grounding-service/docs/api/#grounding_service.ubkg_client.UbkgCandidate","title":"UbkgCandidate  <code>dataclass</code>","text":"<pre><code>UbkgCandidate(code: str, display: str, ontology: str, confidence: float)\n</code></pre> <p>SNOMED candidate returned from UBKG.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>SNOMED concept code.</p> required <code>display</code> <code>str</code> <p>Human-readable concept name.</p> required <code>ontology</code> <code>str</code> <p>Ontology label (e.g., SNOMED CT).</p> required <code>confidence</code> <code>float</code> <p>Confidence or relevance score.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; UbkgCandidate(\n...     code=\"372244006\",\n...     display=\"Malignant melanoma, stage III\",\n...     ontology=\"SNOMED CT\",\n...     confidence=0.92,\n... )\nUbkgCandidate(\n...     code='372244006',\n...     display='Malignant melanoma, stage III',\n...     ontology='SNOMED CT',\n...     confidence=0.92,\n... )\n</code></pre> Notes <p>UBKG returns richer fields; this wireframe focuses on what the HITL UI needs.</p>"},{"location":"grounding-service/docs/api/#grounding_service.ubkg_client.FieldMappingSuggestion","title":"FieldMappingSuggestion  <code>dataclass</code>","text":"<pre><code>FieldMappingSuggestion(field: str, relation: str, value: str, confidence: float)\n</code></pre> <p>Field/relation/value mapping suggestion for a criterion.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>Target field path (e.g., demographics.age).</p> required <code>relation</code> <code>str</code> <p>Comparison operator (e.g., &gt;, &gt;=, =).</p> required <code>value</code> <code>str</code> <p>Normalized value string (e.g., 75).</p> required <code>confidence</code> <code>float</code> <p>Confidence or relevance score.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; FieldMappingSuggestion(\n...     field=\"demographics.age\",\n...     relation=\"&gt;\",\n...     value=\"75\",\n...     confidence=0.87,\n... )\nFieldMappingSuggestion(\n...     field='demographics.age',\n...     relation='&gt;',\n...     value='75',\n...     confidence=0.87,\n... )\n</code></pre> Notes <p>This is a wireframe stub; production mapping will come from a model.</p>"},{"location":"grounding-service/docs/api/#grounding_service.ubkg_client.UbkgClient","title":"UbkgClient","text":"<pre><code>UbkgClient(base_url: str = 'https://ubkg-api.xconsortia.org')\n</code></pre> <p>Client for UBKG REST search endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>Base URL for the UBKG REST API.</p> <code>'https://ubkg-api.xconsortia.org'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; UbkgClient().base_url\n'https://ubkg-api.xconsortia.org'\n</code></pre> Notes <p>This is a wireframe stub; HTTP calls and caching are not implemented. Field mapping suggestions are handled alongside grounding in the production service.</p> <p>Initialize the client with a base URL.</p> Source code in <code>components/grounding-service/src/grounding_service/ubkg_client.py</code> <pre><code>def __init__(self, base_url: str = \"https://ubkg-api.xconsortia.org\") -&gt; None:\n    \"\"\"Initialize the client with a base URL.\"\"\"\n    self.base_url = base_url\n</code></pre> Functions search_snomed <pre><code>search_snomed(query: str, limit: int = 5) -&gt; List[UbkgCandidate]\n</code></pre> <p>Search SNOMED concepts via UBKG.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Free-text clinical concept to search.</p> required <code>limit</code> <code>int</code> <p>Maximum number of candidates to return.</p> <code>5</code> <p>Returns:</p> Type Description <code>List[UbkgCandidate]</code> <p>A list of candidate SNOMED concepts.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the query is empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; UbkgClient().search_snomed(\"stage III melanoma\")\n[]\n</code></pre> Notes <p>The production version will call the UBKG search endpoint and map results into <code>UbkgCandidate</code> instances.</p> Source code in <code>components/grounding-service/src/grounding_service/ubkg_client.py</code> <pre><code>def search_snomed(self, query: str, limit: int = 5) -&gt; List[UbkgCandidate]:\n    \"\"\"Search SNOMED concepts via UBKG.\n\n    Args:\n        query: Free-text clinical concept to search.\n        limit: Maximum number of candidates to return.\n\n    Returns:\n        A list of candidate SNOMED concepts.\n\n    Raises:\n        ValueError: If the query is empty.\n\n    Examples:\n        &gt;&gt;&gt; UbkgClient().search_snomed(\"stage III melanoma\")\n        []\n\n    Notes:\n        The production version will call the UBKG search endpoint and map\n        results into ``UbkgCandidate`` instances.\n    \"\"\"\n    if not query.strip():\n        raise ValueError(\"query is required\")\n\n    lowered = query.lower()\n    candidates: List[UbkgCandidate] = []\n    if \"melanoma\" in lowered:\n        candidates.append(\n            UbkgCandidate(\n                code=\"372244006\",\n                display=\"Malignant melanoma, stage III\",\n                ontology=\"SNOMED CT\",\n                confidence=0.92,\n            )\n        )\n    elif \"age\" in lowered:\n        candidates.append(\n            UbkgCandidate(\n                code=\"371273006\",\n                display=\"Age\",\n                ontology=\"SNOMED CT\",\n                confidence=0.85,\n            )\n        )\n    elif \"pregnant\" in lowered:\n        candidates.append(\n            UbkgCandidate(\n                code=\"77386006\",\n                display=\"Pregnant\",\n                ontology=\"SNOMED CT\",\n                confidence=0.88,\n            )\n        )\n    return candidates[:limit]\n</code></pre>"},{"location":"grounding-service/docs/api/#grounding_service.ubkg_client-functions","title":"Functions","text":""},{"location":"grounding-service/docs/api/#grounding_service.ubkg_client.propose_field_mapping","title":"propose_field_mapping","text":"<pre><code>propose_field_mapping(criterion_text: str) -&gt; List[FieldMappingSuggestion]\n</code></pre> <p>Propose field/relation/value mappings for a criterion.</p> <p>Parameters:</p> Name Type Description Default <code>criterion_text</code> <code>str</code> <p>Criterion text span to map.</p> required <p>Returns:</p> Type Description <code>List[FieldMappingSuggestion]</code> <p>A list of field mapping suggestions.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the criterion text is empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; propose_field_mapping(\"Age &gt;= 75 years\")\n[]\n</code></pre> Notes <p>This is a wireframe stub. The production implementation will use a MedGemma adapter or rule-based parser for field mapping.</p> Source code in <code>components/grounding-service/src/grounding_service/ubkg_client.py</code> <pre><code>def propose_field_mapping(criterion_text: str) -&gt; List[FieldMappingSuggestion]:\n    \"\"\"Propose field/relation/value mappings for a criterion.\n\n    Args:\n        criterion_text: Criterion text span to map.\n\n    Returns:\n        A list of field mapping suggestions.\n\n    Raises:\n        ValueError: If the criterion text is empty.\n\n    Examples:\n        &gt;&gt;&gt; propose_field_mapping(\"Age &gt;= 75 years\")\n        []\n\n    Notes:\n        This is a wireframe stub. The production implementation will use\n        a MedGemma adapter or rule-based parser for field mapping.\n    \"\"\"\n    if not criterion_text.strip():\n        raise ValueError(\"criterion_text is required\")\n\n    match = re.search(r\"age\\s*(&gt;=|&lt;=|=|&gt;|&lt;)\\s*(\\d+)\", criterion_text, re.IGNORECASE)\n    if not match:\n        return []\n\n    relation, value = match.group(1), match.group(2)\n    return [\n        FieldMappingSuggestion(\n            field=\"demographics.age\",\n            relation=relation,\n            value=value,\n            confidence=0.87,\n        )\n    ]\n</code></pre>"},{"location":"hitl-ui/","title":"HITL UI","text":"<p>React/Vite frontend for nurse review of extracted criteria and evidence.</p>"},{"location":"hitl-ui/#scope","title":"Scope","text":"<ul> <li>Display protocols, criteria, and evidence snippets.</li> <li>Provide SNOMED candidate review and edit workflows.</li> <li>Provide field/relation/value mapping review and edits.</li> <li>Capture nurse feedback for audit and retraining.</li> </ul>"},{"location":"hitl-ui/#development","title":"Development","text":"<pre><code>npm install\nnpm run dev\n</code></pre>"},{"location":"hitl-ui/#structure","title":"Structure","text":"<ul> <li><code>src/screens</code> - Top-level views.</li> <li><code>src/features</code> - Feature-specific modules.</li> <li><code>src/components</code> - Shared UI components.</li> <li><code>src/design-system</code> - Tokens, theme, and UI primitives.</li> </ul>"},{"location":"overview/architecture/","title":"Architecture","text":"<p>The system is structured as a component-based monorepo with distinct services for API, extraction, grounding, data ingestion, evaluation, and UI.</p> <pre><code>flowchart LR\n  protocolSource[\"ProtocolSource (CT.gov)\"] --&gt; dataPipeline\n  dataPipeline --&gt; apiService\n  apiService --&gt; extractionService\n  apiService --&gt; groundingService\n  groundingService --&gt; ubkgApi\n  hitlUi --&gt; apiService\n  apiService --&gt; database\n</code></pre>"},{"location":"overview/architecture/#key-integration-points","title":"Key Integration Points","text":"<ul> <li><code>POST /v1/protocols</code> to register protocol metadata and text/PDF.</li> <li><code>POST /v1/protocols/{id}/extract</code> to trigger extraction.</li> <li><code>POST /v1/criteria/{id}/ground</code> to retrieve SNOMED candidates and field/relation/value mapping suggestions.</li> <li><code>POST /v1/hitl/feedback</code> to log nurse actions.</li> </ul>"},{"location":"overview/architecture/#component-responsibilities","title":"Component Responsibilities","text":"Component Responsibilities <code>api-service</code> Orchestration, persistence, request validation, HITL feedback. <code>extraction-service</code> Extract atomic criteria and classify inclusion/exclusion. <code>grounding-service</code> UBKG REST lookup for SNOMED candidates + field/relation/value mapping suggestions. <code>data-pipeline</code> Protocol ingestion and normalization. <code>evaluation</code> Metrics (extraction F1, SNOMED Top-1, field mapping quality, HITL stats). <code>shared</code> Shared schemas and types. <code>hitl-ui</code> Nurse-facing review, edit, and evidence display."},{"location":"overview/architecture/#storage","title":"Storage","text":"<ul> <li><code>protocols</code>: protocol metadata and trial IDs.</li> <li><code>documents</code>: protocol text and provenance.</li> <li><code>criteria</code>: atomic criteria with type and evidence spans.</li> <li><code>groundings</code>: SNOMED candidates, confidence scores, and field/relation/value mappings.</li> <li><code>hitl_edits</code>: nurse actions for audit and retraining.</li> </ul>"},{"location":"overview/getting-started/","title":"Getting Started","text":""},{"location":"overview/getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12</li> <li>UV package manager</li> <li>Node.js 18+ (for HITL UI)</li> <li>Docker (optional, for local DB)</li> </ul>"},{"location":"overview/getting-started/#setup","title":"Setup","text":"<pre><code>uv sync\nmake docs-build\n</code></pre> <p>To serve docs locally:</p> <pre><code>make docs-serve\n</code></pre> <p>To run the API service (wireframe stub):</p> <pre><code>cd components/api-service\nuv run uvicorn api_service.main:app --reload\n</code></pre> <p>To run the data pipeline stub:</p> <pre><code>cd components/data-pipeline\nuv run python -m data_pipeline.download_protocols\n</code></pre> <p>To run the HITL UI:</p> <pre><code>cd components/hitl-ui\nnpm install\nnpm run dev\n</code></pre>"},{"location":"overview/getting-started/#scripts","title":"Scripts","text":"<p>The repository includes utility scripts in the <code>scripts/</code> directory for common tasks.</p>"},{"location":"overview/getting-started/#protocol-download-tool","title":"Protocol Download Tool","text":"<p>The protocol download tool (<code>scripts/download_protocol_sources.py</code>) downloads clinical trial protocol PDFs from multiple sources for use in the data pipeline.</p> <p>Basic Usage:</p> <pre><code># Download protocols from all sources (default settings)\npython scripts/download_protocol_sources.py\n</code></pre> <p>Advanced Usage:</p> <pre><code># Download from specific sources only\npython scripts/download_protocol_sources.py --sources dac jmir\n\n# Limit the number of downloads\npython scripts/download_protocol_sources.py --max-per-source 10 --max-total 30\n\n# Use a custom output directory\npython scripts/download_protocol_sources.py --output-dir data/my-protocols\n</code></pre> <p>Available Sources: - <code>dac</code>: Data Access Committee protocol registry - <code>clinicaltrials</code>: ClinicalTrials.gov study protocols - <code>bmjopen</code>: BMJ Open protocol articles - <code>jmir</code>: JMIR Research Protocols</p> <p>Output: - PDFs are saved to <code>data/protocols/</code> (or specified directory) organized by source - A <code>manifest.jsonl</code> file tracks all download attempts with metadata</p> <p>Command-Line Options: - <code>--output-dir PATH</code>: Directory for downloaded PDFs (default: <code>data/protocols</code>) - <code>--sources SOURCE [SOURCE ...]</code>: Sources to download from (default: all) - <code>--max-per-source N</code>: Maximum PDFs per source (default: 50) - <code>--max-total N</code>: Maximum PDFs overall (default: 200) - <code>--timeout SECONDS</code>: Network timeout (default: 30) - <code>--sitemap-limit N</code>: Sitemap files to scan per source (default: 2)</p>"},{"location":"overview/getting-started/#development-scripts","title":"Development Scripts","text":"<ul> <li><code>scripts/create_component.sh</code>: Creates a new component with proper structure, dependencies, and documentation setup</li> <li><code>scripts/generate_components_overview.py</code>: Auto-generates the components overview page from component metadata</li> <li><code>scripts/update_root_navigation.py</code>: Updates the root mkdocs.yml navigation with all discovered components</li> </ul>"},{"location":"overview/getting-started/#testing","title":"Testing","text":"<p>Each Python component includes a Makefile with linting, type-checking, and test targets:</p> <pre><code>cd components/api-service\nmake check-all\n</code></pre>"},{"location":"overview/hackathon-plan/","title":"MedGemma Hackathon \u2013 Concise Operational Plan","text":"<p>Goal: Deliver a hackathon\u2011ready MedGemma HITL demo that extracts atomic inclusion/exclusion criteria from trial protocols, grounds them to SNOMED via UBKG, and maps criteria to field/relation/value (e.g., <code>demographics.age &gt; 75</code>), with a clear ElixirTrials integration story.</p>"},{"location":"overview/hackathon-plan/#1-project-brief","title":"1. Project Brief","text":""},{"location":"overview/hackathon-plan/#11-problem-impact","title":"1.1 Problem &amp; Impact","text":"<ul> <li>Clinical trial protocols are unstructured; screening is slow and error\u2011prone.</li> <li>We build an AI\u2011assisted system that:</li> <li>Extracts atomic inclusion/exclusion criteria from protocols.</li> <li>Maps them to SNOMED (via UBKG REST API).</li> <li>Maps criteria to field + relation + value for EMR screening (e.g., <code>demographics.age &gt; 75</code>).</li> <li>Lets a nurse reviewer correct mappings through a simple HITL UI.</li> <li>Target time savings: ~65\u201370% nurse time per protocol vs. manual review.  </li> </ul>"},{"location":"overview/hackathon-plan/#12-success-criteria-hackathon","title":"1.2 Success Criteria (Hackathon)","text":"<p>Judging\u2011aligned: 1. Human\u2011Centered AI    - Simple, transparent HITL UI.    - Shows provenance (evidence snippets) + confidence scores.    - Nurse can accept/edit SNOMED codes and field/relation/value mappings inline.</p> <ol> <li>Technical Rigor</li> <li>MedGemma 1.5\u20134B\u2011IT with LoRA adapters for:<ul> <li>Task A: Criteria extraction.</li> <li>Task B: SNOMED grounding + field/relation/value mapping.</li> </ul> </li> <li> <p>8\u2011bit quantized inference on DGX Spark\u2011class hardware.</p> </li> <li> <p>Impact &amp; Feasibility</p> </li> <li>Measured extraction F1 and SNOMED Top\u20111 accuracy.</li> <li>Measured time per protocol: baseline vs AI\u2011assisted.</li> <li>Clear story to plug into ElixirTrials/Cauldron.</li> </ol> <p>Quantitative Targets (Hackathon): - Extraction F1: \u2265 0.85 - SNOMED Top\u20111 accuracy: \u2265 0.80 - Nurse acceptance rate: \u2265 70% - Time per protocol: \u2265 60% reduction vs manual.</p>"},{"location":"overview/hackathon-plan/#2-scope","title":"2. Scope","text":""},{"location":"overview/hackathon-plan/#21-in-scope-hackathon","title":"2.1 In Scope (Hackathon)","text":"<ul> <li>Ingest public ClinicalTrials.gov protocols (200\u2013300).</li> <li>Extract atomic inclusion/exclusion criteria.</li> <li>Ground criteria to SNOMED via UBKG REST API (no external dependencies beyond public APIs).</li> <li>Map criteria to field + relation + value for EMR screening (field\u2011value mapping).</li> <li>HITL backend:</li> <li>Save criteria, suggested codes, and nurse edits.</li> <li>Simple review UI (Gradio or minimal React view).</li> <li>LoRA fine\u2011tuning of MedGemma on nurse\u2011validated labels.</li> <li>8\u2011bit quantized inference on DGX Spark\u2011class workstation.</li> <li>Kaggle deliverables:</li> <li>Writeup.</li> <li>Training/eval notebook.</li> <li>GitHub repo.</li> <li>3\u20135 min video demo.</li> </ul>"},{"location":"overview/hackathon-plan/#22-out-of-scope-posthackathon-only","title":"2.2 Out of Scope (Post\u2011Hackathon Only)","text":"<ul> <li>Federated learning / multi\u2011site aggregation.</li> <li>EMR / FHIR / Redox integration.</li> <li>Patient\u2011level screening &amp; matching.</li> <li>Full Triplane/Screening integration.</li> </ul>"},{"location":"overview/hackathon-plan/#3-architecture-highlevel","title":"3. Architecture (High\u2011Level)","text":""},{"location":"overview/hackathon-plan/#31-data-flow","title":"3.1 Data Flow","text":"<ol> <li>Protocol Upload</li> <li>Input: PDF/text from ClinicalTrials.gov.</li> <li> <p>Stored as <code>protocol</code> and <code>document</code> rows.</p> </li> <li> <p>Extraction</p> </li> <li>Endpoint: <code>POST /v1/protocols/{id}/extract</code></li> <li> <p>Uses MedGemma (LoRA Task A) \u2192 atomic criteria + type.</p> </li> <li> <p>Grounding</p> </li> <li>Endpoint: <code>POST /v1/criteria/{id}/ground</code></li> <li> <p>UBKG REST API (terminology lookup) + MedGemma (LoRA Task B) \u2192 ranked SNOMED codes + field/relation/value mapping.</p> </li> <li> <p>HITL Review</p> </li> <li>Nurse UI fetches:<ul> <li>Criteria list.</li> <li>Suggested SNOMED codes + confidence + evidence snippets.</li> <li>Suggested field/relation/value mapping (e.g., <code>demographics.age &gt; 75</code>).</li> </ul> </li> <li> <p>Nurse edits logged in <code>hitl_edits</code>.</p> </li> <li> <p>Retraining Loop (Single\u2011site)</p> </li> <li>Export edits as new training data.</li> <li>Periodic LoRA re\u2011training of MedGemma adapters.</li> </ol>"},{"location":"overview/hackathon-plan/#32-minimal-api-contract-hackathon","title":"3.2 Minimal API Contract (Hackathon)","text":"<p>Base URL: <code>/v1</code></p> <ul> <li><code>POST /v1/protocols</code></li> <li>Create protocol metadata + initial document (text or PDF).</li> <li><code>POST /v1/protocols/{protocolId}/extract</code></li> <li>Trigger criteria extraction (sync is enough).</li> <li><code>GET /v1/protocols/{protocolId}/criteria</code></li> <li>List criteria for review.</li> <li><code>PATCH /v1/criteria/{criterionId}</code></li> <li>Edit criterion text/type/etc.</li> <li><code>POST /v1/criteria/{criterionId}/ground</code></li> <li>Get SNOMED candidates via UBKG REST API + field/relation/value mapping.</li> <li><code>POST /v1/hitl/feedback</code></li> <li>Log nurse actions (accept/remove/add code etc).</li> </ul> <p>(Full OpenAPI spec lives in <code>docs/api_spec.yaml</code>.)</p>"},{"location":"overview/hackathon-plan/#33-core-components","title":"3.3 Core Components","text":"Component Tech / Notes Backend API FastAPI (Python) Model Inference MedGemma 1.5\u20134B\u2011IT + LoRA (8\u2011bit) Terminology UBKG REST API (no custom wrapper) DB PostgreSQL (protocols, criteria, edits) HITL UI Gradio or minimal Cauldron\u2011style view Hardware DGX Spark\u2011class GPU workstation"},{"location":"overview/hackathon-plan/#34-ubkg-integration","title":"3.4 UBKG Integration","text":"<p>Why UBKG: - Pre\u2011built, production\u2011grade knowledge graph combining UMLS + external ontologies. - REST API + Neo4j options. - Zero licensing overhead for hackathon (public/research access). - Multi\u2011terminology support (SNOMED, LOINC, RxNorm, ICD\u201110) built\u2011in.</p> <p>Usage Pattern:</p> <pre><code># Lookup term in UBKG\nPOST https://ubkg-api.xconsortia.org/search\n{\n  \"query\": \"stage III melanoma\",\n  \"ontology\": \"SNOMED\",\n  \"limit\": 5\n}\n\n# Response includes SNOMED codes + definitions + related terms\n{\n  \"results\": [\n    {\n      \"code\": \"372244006\",\n      \"display\": \"Malignant melanoma, stage III\",\n      \"ontology\": \"SNOMED CT\",\n      \"confidence\": 0.92\n    }\n  ]\n}\n</code></pre> <p>Implementation: - Simple HTTP client in <code>backend/ubkg_client.py</code>. - Optional local caching (Redis or in\u2011memory) for frequent lookups. - Fallback to pre\u2011cached SNOMED subset if API unavailable.</p>"},{"location":"overview/hackathon-plan/#4-sprints-daily-execution","title":"4. Sprints &amp; Daily Execution","text":""},{"location":"overview/hackathon-plan/#41-week-1-data-ubkg-integration-jan-1521","title":"4.1 Week 1 \u2013 Data &amp; UBKG Integration (Jan 15\u201321)","text":"<p>Goals: - Have protocols in DB. - UBKG API client working + cached. - Minimal extraction pipeline running (base model).</p> <p>Tasks:</p> <ul> <li>Data &amp; DB</li> <li>Implement <code>scripts/download_protocols.py</code> to fetch 200\u2013300 oncology/cardio trials from ClinicalTrials.gov.</li> <li>Store <code>{nct_id, title, i/e text, condition, phase}</code> in PostgreSQL.</li> <li> <p>Define DB schema:</p> <ul> <li><code>protocols</code>, <code>documents</code>, <code>criteria</code>, <code>groundings</code>, <code>hitl_edits</code>.</li> </ul> </li> <li> <p>UBKG Integration</p> </li> <li>Implement <code>backend/ubkg_client.py</code>:<ul> <li>HTTP client to UBKG REST API.</li> <li>Query term \u2192 get SNOMED candidates.</li> <li>Simple in\u2011memory cache (TTL configurable).</li> <li>Fallback: load local SNOMED subset (CSV from UBKG downloads).</li> </ul> </li> <li> <p>CLI smoke test: terms like \"stage III melanoma\", \"ECOG PS 0\u20131\".</p> </li> <li> <p>Baseline Extraction</p> </li> <li>Implement rough parsing of I/E sections into candidate criteria (regex/sentence splitting).</li> <li>Run base MedGemma (no LoRA) for:<ul> <li>Type classification (inclusion/exclusion).</li> <li>Draft SNOMED suggestions via UBKG.</li> <li>Draft field/relation/value mapping suggestions.</li> </ul> </li> </ul> <p>Decision / Risk: - By end of Week 1:   - If UBKG API rate limits hit \u2192 use local SNOMED subset file only.</p>"},{"location":"overview/hackathon-plan/#42-week-2-hitl-labeling-jan-2228","title":"4.2 Week 2 \u2013 HITL &amp; Labeling (Jan 22\u201328)","text":"<p>Goals: - Usable HITL UI for nurse. - ~1,000 labeled examples for training.</p> <p>Tasks:</p> <ul> <li>HITL UI (MVP)</li> <li>Build simple UI (Gradio or minimal React) with:<ul> <li>Protocol text on left, highlighted criterion.</li> <li>Criterion card on right:</li> <li>Type, text, confidence.</li> <li>SNOMED candidates with checkboxes.</li> <li>Field/relation/value mapping preview + edits.</li> <li>Add/remove code, rationale.</li> </ul> </li> <li> <p>Wire to backend:</p> <ul> <li><code>GET /protocols/{id}/criteria</code></li> <li><code>POST /criteria/{id}/ground</code></li> <li><code>POST /hitl/feedback</code>.</li> </ul> </li> <li> <p>Annotation Workflow</p> </li> <li>Pre\u2011label criteria using base MedGemma + UBKG:<ul> <li>Save as <code>criteria_prelabeled.jsonl</code>.</li> </ul> </li> <li>Define gold label schema (criterion text, type, SNOMED codes, field/relation/value, evidence spans).</li> <li>Target: ~1,000 validated criteria (spanning ~120 protocols).</li> <li> <p>Coordinate nurse schedule (~200h total across hackathon).</p> </li> <li> <p>Dataset Preparation</p> </li> <li>Create train/val/test splits:<ul> <li>Train: 1,000 examples (~120 protocols).</li> <li>Val: 100 examples (~15 protocols).</li> <li>Test: 100 examples (held\u2011out conditions).</li> </ul> </li> </ul> <p>Decision / Risk: - If by end of Week 2:   - &lt;700 labeled examples \u2192 reduce model ambition (e.g., only Task B LoRA) and focus on demo quality.</p>"},{"location":"overview/hackathon-plan/#43-week-3-training-backend-jan-29feb-4","title":"4.3 Week 3 \u2013 Training &amp; Backend (Jan 29\u2013Feb 4)","text":"<p>Goals: - LoRA adapters trained and deployed. - Backend API stable. - Basic metrics computed.</p> <p>Tasks:</p> <ul> <li>Model Training</li> <li>Task A (Extraction):<ul> <li>LoRA config: <code>r=16</code>, <code>alpha=32</code>, target <code>q_proj/v_proj/o_proj</code>.</li> <li>3 epochs, batch size 4 (grad accum 4), lr <code>2e\u20114</code>.</li> </ul> </li> <li>Task B (Grounding):<ul> <li>Separate LoRA adapter, same config.</li> <li>Training data from nurse\u2011validated mapping + UBKG candidates.</li> </ul> </li> <li> <p>Use 8\u2011bit QLoRA on DGX Spark; save adapters in <code>models/</code>.</p> </li> <li> <p>Backend Hardening</p> </li> <li>Implement final versions of:<ul> <li><code>POST /protocols</code></li> <li><code>POST /protocols/{id}/extract</code></li> <li><code>GET /protocols/{id}/criteria</code></li> <li><code>PATCH /criteria/{id}</code></li> <li><code>POST /criteria/{id}/ground</code></li> <li><code>POST /hitl/feedback</code></li> </ul> </li> <li>Add logging &amp; basic error handling.</li> <li> <p>Add minimal tests (Pytest) for core API paths.</p> </li> <li> <p>Evaluation</p> </li> <li>Run on test set:<ul> <li>Extraction F1.</li> <li>SNOMED Top\u20111 accuracy.</li> <li>Field/relation/value mapping quality.</li> <li>Nurse acceptance rate on small test batch.</li> </ul> </li> <li>Measure:<ul> <li>Time per protocol (manual vs AI\u2011assisted with small pilot).</li> <li>Inference latency per protocol (&lt;15s target).</li> </ul> </li> </ul> <p>Stretch (Only if above done early): - Toy federated simulation with 2\u20133 synthetic \"sites\" using site splits.</p>"},{"location":"overview/hackathon-plan/#44-week-4-demo-writeup-polish-feb-512","title":"4.4 Week 4 \u2013 Demo, Writeup &amp; Polish (Feb 5\u201312)","text":"<p>Goals: - Kaggle submission ready. - Demo smooth and reproducible.</p> <p>Tasks:</p> <ul> <li>Demo Experience</li> <li>End\u2011to\u2011end flow:<ol> <li>Upload or select existing protocol.</li> <li>Run extraction.</li> <li>Show criteria list with SNOMED codes + field/relation/value &amp; confidence.</li> <li>Perform a couple of nurse edits.</li> <li>Show metrics/time\u2011saved panel.</li> </ol> </li> <li> <p>Ensure no manual dev hacks (one\u2011command run via Docker Compose).</p> </li> <li> <p>Kaggle Writeup</p> </li> <li> <p>Sections (with word limits):</p> <ol> <li>Problem &amp; Impact (~300 words).</li> <li>Architecture (~400\u2013500 words + 1 diagram).</li> <li>Human\u2011in\u2011the\u2011loop workflow (~300 words).</li> <li>Model &amp; Training (~400\u2013500 words).</li> <li>Results &amp; Error Analysis (~400\u2013500 words).</li> <li>ElixirTrials Integration Roadmap (~300\u2013400 words).</li> <li>Reproducibility &amp; Open Source (~200 words).</li> </ol> </li> <li> <p>Notebook</p> </li> <li> <p><code>notebooks/training_pipeline.ipynb</code>:</p> <ul> <li>Load sample data.</li> <li>Show preprocessing.</li> <li>Demo LoRA training steps (small subset for Kaggle runtime).</li> <li>Show metrics + inference example.</li> </ul> </li> <li> <p>GitHub Repo</p> </li> <li>Structure:     <code>text     gemma-hackathon/       backend/         main.py         models/         ubkg_client.py         tests/       notebooks/       data/ (small sample only)       docs/         api_spec.yaml         architecture.md         ubkg_notes.md       docker-compose.yml       README.md</code></li> <li> <p>README:</p> <ul> <li>One\u2011command run.</li> <li>Hardware assumptions.</li> <li>UBKG API &amp; UMLS licensing notes.</li> <li>\"Demo only \u2013 not for clinical use\" disclaimer.</li> </ul> </li> <li> <p>Video (3\u20135 min)</p> </li> <li>Script:<ul> <li>30s: Problem framing.</li> <li>60\u201390s: Live demo of upload \u2192 extraction \u2192 review.</li> <li>60s: Metrics summary.</li> <li>30\u201360s: ElixirTrials integration story.</li> </ul> </li> </ul>"},{"location":"overview/hackathon-plan/#5-key-implementation-notes","title":"5. Key Implementation Notes","text":""},{"location":"overview/hackathon-plan/#51-umls-approval-already-secured","title":"5.1 UMLS Approval Already Secured","text":"<p>\u2705 No NLM license delay; proceed directly with full deployment.</p>"},{"location":"overview/hackathon-plan/#52-ubkg-as-single-source-of-truth","title":"5.2 UBKG as Single Source of Truth","text":"<ul> <li>Use UBKG REST API for all terminology lookups (SNOMED, LOINC, RxNorm, ICD\u201110).</li> <li>No custom wrapper needed; simple HTTP client + optional caching.</li> <li>Fallback: pre\u2011download SNOMED subset as CSV from UBKG downloads.</li> </ul>"},{"location":"overview/hackathon-plan/#53-data-privacy","title":"5.3 Data Privacy","text":"<ul> <li>All protocols and edits stay in\u2011prem during hackathon.</li> <li>Only LoRA adapter weights and anonymized metrics shared post\u2011hackathon.</li> </ul>"},{"location":"overview/hackathon-plan/#6-metrics-decision-gates","title":"6. Metrics &amp; Decision Gates","text":""},{"location":"overview/hackathon-plan/#61-core-metrics","title":"6.1 Core Metrics","text":"<ul> <li>Extraction (Task A)</li> <li>F1 on test set.</li> <li>Grounding (Task B)</li> <li>SNOMED Top\u20111 accuracy.</li> <li>Field Mapping</li> <li>Field/relation/value mapping quality.</li> <li>HITL</li> <li>Nurse acceptance rate.</li> <li>Time per protocol (manual vs AI\u2011assisted).</li> </ul>"},{"location":"overview/hackathon-plan/#62-go-nogo-for-stretch-work-federated-prototype","title":"6.2 Go / No\u2011Go for Stretch Work (Federated Prototype)","text":"<ul> <li>Only attempt if by end of Week 3:</li> <li>Extraction F1 \u2265 0.85.</li> <li>SNOMED Top\u20111 \u2265 0.80.</li> <li>End\u2011to\u2011end demo stable.</li> <li>At least 120 protocols annotated.</li> </ul> <p>Otherwise, invest Week 4 fully in polish, metrics clarity, and submission quality.</p>"},{"location":"overview/hackathon-plan/#7-submission-checklist","title":"7. Submission Checklist","text":""},{"location":"overview/hackathon-plan/#t72-hours","title":"T\u201172 Hours","text":"<ul> <li>[ ] Run Docker Compose from clean environment.</li> <li>[ ] Run Kaggle notebook from top to bottom on Kaggle GPU.</li> <li>[ ] Freeze model artifacts (tagged release in GitHub).</li> </ul>"},{"location":"overview/hackathon-plan/#t24-hours","title":"T\u201124 Hours","text":"<ul> <li>[ ] Finalize Kaggle writeup text.</li> <li>[ ] Upload demo video (YouTube unlisted).</li> <li>[ ] Verify all GitHub + notebook links.</li> </ul>"},{"location":"overview/hackathon-plan/#t0","title":"T\u20110","text":"<ul> <li>[ ] Submit Kaggle entry and confirm appearance in challenge.</li> <li>[ ] Backup repo + models to long\u2011term storage.</li> <li>[ ] Note learnings + next\u2011steps for ElixirTrials production track.</li> </ul>"},{"location":"overview/project/","title":"Project Overview","text":"<p>The MedGemma hackathon demo focuses on protocol ingestion, criteria extraction, UBKG grounding, field/relation/value mapping, and HITL review. The objective is to reduce nurse review time while preserving transparency and provenance.</p>"},{"location":"overview/project/#scope","title":"Scope","text":"<ul> <li>Protocol ingestion and parsing.</li> <li>Criteria extraction and classification.</li> <li>SNOMED grounding via UBKG.</li> <li>Field/relation/value mapping for EMR screening.</li> <li>HITL UI for review and corrections.</li> <li>Minimal evaluation metrics.</li> </ul>"},{"location":"overview/project/#success-criteria","title":"Success Criteria","text":"<ul> <li>Extraction F1 &gt;= 0.85.</li> <li>SNOMED Top-1 accuracy &gt;= 0.80.</li> <li>Field/relation/value mapping quality tracked (target TBD).</li> <li>Nurse acceptance rate &gt;= 70%.</li> <li>Time per protocol reduction &gt;= 60% vs manual.</li> </ul>"},{"location":"overview/project/#deliverables","title":"Deliverables","text":"<ul> <li>End-to-end demo (protocol -&gt; extraction -&gt; grounding + field mapping -&gt; HITL edits).</li> <li>API spec and component documentation.</li> <li>Training and evaluation notebook.</li> <li>3-5 minute demo video.</li> </ul>"},{"location":"overview/project/#out-of-scope-post-hackathon","title":"Out of Scope (Post-Hackathon)","text":"<ul> <li>EMR/FHIR integration.</li> <li>Multi-site federated learning.</li> <li>Patient-level screening and matching.</li> </ul>"},{"location":"phases/week-1/","title":"Week 1 - Data &amp; UBKG Integration","text":"<ul> <li>Ingest protocols into the database.</li> <li>Implement UBKG client with caching.</li> <li>Baseline extraction pipeline.</li> </ul> <p>See <code>docs/overview/hackathon-plan.md</code> for full details.</p>"},{"location":"phases/week-2/","title":"Week 2 - HITL &amp; Labeling","text":"<ul> <li>Build HITL UI MVP.</li> <li>Collect labeled examples.</li> <li>Prepare dataset splits.</li> </ul> <p>See <code>docs/overview/hackathon-plan.md</code> for full details.</p>"},{"location":"phases/week-3/","title":"Week 3 - Training &amp; Backend","text":"<ul> <li>Train LoRA adapters.</li> <li>Harden API endpoints.</li> <li>Add basic evaluation metrics.</li> </ul> <p>See <code>docs/overview/hackathon-plan.md</code> for full details.</p>"},{"location":"phases/week-4/","title":"Week 4 - Demo &amp; Polish","text":"<ul> <li>End-to-end demo flow.</li> <li>Finalize writeup and video.</li> <li>Ensure reproducibility.</li> </ul> <p>See <code>docs/overview/hackathon-plan.md</code> for full details.</p>"},{"location":"shared/","title":"shared","text":"<p>Shared data models and schemas used by API services and the UI.</p>"},{"location":"shared/#responsibilities","title":"Responsibilities","text":"<ul> <li>Define canonical data structures for protocols, criteria, groundings, and field/relation/value mappings.</li> <li>Keep type definitions synchronized across services.</li> </ul>"},{"location":"shared/#key-module","title":"Key Module","text":"<ul> <li><code>shared/models.py</code></li> </ul>"},{"location":"shared/#example-usage","title":"Example Usage","text":"<pre><code>from shared.models import Criterion\n\ncriterion = Criterion(\n    id=\"crit-1\",\n    text=\"Age &gt;= 18 years\",\n    criterion_type=\"inclusion\",\n    confidence=0.92,\n    snomed_codes=[\"371273006\"],\n)\n</code></pre>"},{"location":"shared/#tests","title":"Tests","text":"<pre><code>make check-all\n</code></pre>"},{"location":"shared/docs/api/","title":"shared API Reference","text":"<p>This page contains automatically generated API documentation for the shared component.</p>"},{"location":"shared/docs/api/#api-documentation","title":"API Documentation","text":""},{"location":"shared/docs/api/#shared","title":"shared","text":"<p>shared package.</p>"},{"location":"shared/docs/api/#shared-modules","title":"Modules","text":""},{"location":"shared/docs/api/#shared.models","title":"models","text":"<p>Shared data models for API and UI.</p>"},{"location":"shared/docs/api/#shared.models-classes","title":"Classes","text":""},{"location":"shared/docs/api/#shared.models.Criterion","title":"Criterion  <code>dataclass</code>","text":"<pre><code>Criterion(id: str, text: str, criterion_type: str, confidence: float, snomed_codes: List[str], evidence_spans: List[EvidenceSpan] = list())\n</code></pre> <p>Atomic criterion extracted from a protocol.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Stable identifier for the criterion.</p> required <code>text</code> <code>str</code> <p>Criterion text.</p> required <code>criterion_type</code> <code>str</code> <p>Inclusion or exclusion label.</p> required <code>confidence</code> <code>float</code> <p>Model confidence score.</p> required <code>snomed_codes</code> <code>List[str]</code> <p>SNOMED codes attached to the criterion.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; Criterion(\n...     id=\"crit-1\",\n...     text=\"Age &gt;= 18 years\",\n...     criterion_type=\"inclusion\",\n...     confidence=0.92,\n...     snomed_codes=[\"371273006\"],\n... )\nCriterion(\n...     id='crit-1',\n...     text='Age &gt;= 18 years',\n...     criterion_type='inclusion',\n...     confidence=0.92,\n...     snomed_codes=['371273006'],\n... )\n</code></pre> Notes <p>Evidence spans and grounding candidates are stored separately.</p>"},{"location":"shared/docs/api/#shared.models.EvidenceSpan","title":"EvidenceSpan  <code>dataclass</code>","text":"<pre><code>EvidenceSpan(start_char: int, end_char: int, source_doc_id: str)\n</code></pre> <p>Evidence span linking criterion to source document.</p> <p>Parameters:</p> Name Type Description Default <code>start_char</code> <code>int</code> <p>Starting character offset in source.</p> required <code>end_char</code> <code>int</code> <p>Ending character offset in source.</p> required <code>source_doc_id</code> <code>str</code> <p>Document identifier for provenance.</p> required"},{"location":"shared/docs/api/#shared.models.FieldMapping","title":"FieldMapping  <code>dataclass</code>","text":"<pre><code>FieldMapping(field: str, relation: str, value: str, confidence: Optional[float] = None)\n</code></pre> <p>Field/relation/value mapping attached to a criterion.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>Target field path (e.g., demographics.age).</p> required <code>relation</code> <code>str</code> <p>Comparison operator (e.g., &gt;, &gt;=, =).</p> required <code>value</code> <code>str</code> <p>Normalized value string (e.g., 75).</p> required <code>confidence</code> <code>Optional[float]</code> <p>Optional confidence score.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; FieldMapping(\n...     field=\"demographics.age\",\n...     relation=\"&gt;\",\n...     value=\"75\",\n...     confidence=0.87,\n... )\nFieldMapping(\n...     field='demographics.age',\n...     relation='&gt;',\n...     value='75',\n...     confidence=0.87,\n... )\n</code></pre> Functions to_string <pre><code>to_string() -&gt; str\n</code></pre> <p>Serialize to pipe-delimited string.</p> Source code in <code>components/shared/src/shared/models.py</code> <pre><code>def to_string(self) -&gt; str:\n    \"\"\"Serialize to pipe-delimited string.\"\"\"\n    return f\"{self.field}|{self.relation}|{self.value}\"\n</code></pre> from_string <code>classmethod</code> <pre><code>from_string(value: str) -&gt; FieldMapping\n</code></pre> <p>Deserialize from pipe-delimited string.</p> Source code in <code>components/shared/src/shared/models.py</code> <pre><code>@classmethod\ndef from_string(cls, value: str) -&gt; \"FieldMapping\":\n    \"\"\"Deserialize from pipe-delimited string.\"\"\"\n    parts = value.split(\"|\")\n    if len(parts) != 3:\n        raise ValueError(\n            \"Invalid field mapping string: \"\n            f\"'{value}'. Expected format 'field|relation|value' \"\n            \"(e.g., 'demographics.age|&gt;=|18').\"\n        )\n    return cls(field=parts[0], relation=parts[1], value=parts[2])\n</code></pre>"},{"location":"shared/docs/api/#shared.models.Protocol","title":"Protocol  <code>dataclass</code>","text":"<pre><code>Protocol(id: str, title: str, nct_id: str, condition: str, phase: str)\n</code></pre> <p>Protocol metadata tracked by the API.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Stable protocol identifier.</p> required <code>title</code> <code>str</code> <p>Human-readable trial title.</p> required <code>nct_id</code> <code>str</code> <p>ClinicalTrials.gov identifier.</p> required <code>condition</code> <code>str</code> <p>Primary disease/condition.</p> required <code>phase</code> <code>str</code> <p>Trial phase label.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; Protocol(\n...     id=\"proto-1\",\n...     title=\"Example Trial\",\n...     nct_id=\"NCT00000000\",\n...     condition=\"Melanoma\",\n...     phase=\"Phase 2\",\n... )\nProtocol(\n...     id='proto-1',\n...     title='Example Trial',\n...     nct_id='NCT00000000',\n...     condition='Melanoma',\n...     phase='Phase 2',\n... )\n</code></pre>"},{"location":"shared/docs/api/#shared.models.Document","title":"Document  <code>dataclass</code>","text":"<pre><code>Document(id: str, protocol_id: str, text: str, source_url: Optional[str])\n</code></pre> <p>Protocol document content and provenance.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Document identifier.</p> required <code>protocol_id</code> <code>str</code> <p>Associated protocol identifier.</p> required <code>text</code> <code>str</code> <p>Extracted protocol text.</p> required <code>source_url</code> <code>Optional[str]</code> <p>Optional source URL for provenance.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; Document(\n...     id=\"doc-1\",\n...     protocol_id=\"proto-1\",\n...     text=\"Inclusion: ...\",\n...     source_url=None,\n... )\nDocument(\n...     id='doc-1',\n...     protocol_id='proto-1',\n...     text='Inclusion: ...',\n...     source_url=None,\n... )\n</code></pre>"},{"location":"shared/docs/api/#shared.models.GroundingCandidate","title":"GroundingCandidate  <code>dataclass</code>","text":"<pre><code>GroundingCandidate(code: str, display: str, confidence: float)\n</code></pre> <p>SNOMED candidate for a criterion grounding decision.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>SNOMED concept code.</p> required <code>display</code> <code>str</code> <p>Human-readable concept description.</p> required <code>confidence</code> <code>float</code> <p>Model or retrieval confidence score.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; GroundingCandidate(\n...     code=\"372244006\",\n...     display=\"Malignant melanoma, stage III\",\n...     confidence=0.92,\n... )\nGroundingCandidate(\n...     code='372244006',\n...     display='Malignant melanoma, stage III',\n...     confidence=0.92,\n... )\n</code></pre>"},{"location":"shared/docs/api/#shared.models.HitlEdit","title":"HitlEdit  <code>dataclass</code>","text":"<pre><code>HitlEdit(id: str, criterion_id: str, action: str, note: Optional[str], snomed_code_added: Optional[str] = None, snomed_code_removed: Optional[str] = None, field_mapping_added: Optional[str] = None, field_mapping_removed: Optional[str] = None)\n</code></pre> <p>Human-in-the-loop edit captured from a nurse reviewer.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Edit identifier.</p> required <code>criterion_id</code> <code>str</code> <p>Criterion updated by the reviewer.</p> required <code>action</code> <code>str</code> <p>Action label (accept, reject, add, edit).</p> required <code>note</code> <code>Optional[str]</code> <p>Optional rationale or comment.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; HitlEdit(\n...     id=\"edit-1\",\n...     criterion_id=\"crit-1\",\n...     action=\"accept\",\n...     note=\"Matches protocol text\",\n... )\nHitlEdit(\n...     id='edit-1',\n...     criterion_id='crit-1',\n...     action='accept',\n...     note='Matches protocol text',\n... )\n</code></pre>"},{"location":"shared/docs/api/#shared.models-functions","title":"Functions","text":""},{"location":"shared/docs/api/#shared.models.build_criterion","title":"build_criterion","text":"<pre><code>build_criterion(*, id: str = 'crit-1', text: str = 'Age &gt;= 18 years', criterion_type: str = 'inclusion', confidence: float = 0.92, snomed_codes: Optional[List[str]] = None, evidence_spans: Optional[List[EvidenceSpan]] = None) -&gt; Criterion\n</code></pre> <p>Create a Criterion instance with defaults for tests and examples.</p> Source code in <code>components/shared/src/shared/models.py</code> <pre><code>def build_criterion(\n    *,\n    id: str = \"crit-1\",\n    text: str = \"Age &gt;= 18 years\",\n    criterion_type: str = \"inclusion\",\n    confidence: float = 0.92,\n    snomed_codes: Optional[List[str]] = None,\n    evidence_spans: Optional[List[EvidenceSpan]] = None,\n) -&gt; Criterion:\n    \"\"\"Create a Criterion instance with defaults for tests and examples.\"\"\"\n    return Criterion(\n        id=id,\n        text=text,\n        criterion_type=criterion_type,\n        confidence=confidence,\n        snomed_codes=snomed_codes or [\"371273006\"],\n        evidence_spans=evidence_spans or [],\n    )\n</code></pre>"},{"location":"shared/docs/api/#shared.models.build_field_mapping","title":"build_field_mapping","text":"<pre><code>build_field_mapping(*, field: str = 'demographics.age', relation: str = '&gt;=', value: str = '18', confidence: Optional[float] = 0.87) -&gt; FieldMapping\n</code></pre> <p>Create a FieldMapping instance with defaults for tests and examples.</p> Source code in <code>components/shared/src/shared/models.py</code> <pre><code>def build_field_mapping(\n    *,\n    field: str = \"demographics.age\",\n    relation: str = \"&gt;=\",\n    value: str = \"18\",\n    confidence: Optional[float] = 0.87,\n) -&gt; FieldMapping:\n    \"\"\"Create a FieldMapping instance with defaults for tests and examples.\"\"\"\n    return FieldMapping(\n        field=field,\n        relation=relation,\n        value=value,\n        confidence=confidence,\n    )\n</code></pre>"},{"location":"shared/docs/api/#shared.models.build_protocol","title":"build_protocol","text":"<pre><code>build_protocol(*, id: str = 'proto-1', title: str = 'Example Trial', nct_id: str = 'NCT00000000', condition: str = 'Melanoma', phase: str = 'Phase 2') -&gt; Protocol\n</code></pre> <p>Create a Protocol instance with defaults for tests and examples.</p> Source code in <code>components/shared/src/shared/models.py</code> <pre><code>def build_protocol(\n    *,\n    id: str = \"proto-1\",\n    title: str = \"Example Trial\",\n    nct_id: str = \"NCT00000000\",\n    condition: str = \"Melanoma\",\n    phase: str = \"Phase 2\",\n) -&gt; Protocol:\n    \"\"\"Create a Protocol instance with defaults for tests and examples.\"\"\"\n    return Protocol(\n        id=id,\n        title=title,\n        nct_id=nct_id,\n        condition=condition,\n        phase=phase,\n    )\n</code></pre>"},{"location":"shared/docs/api/#shared.models.build_document","title":"build_document","text":"<pre><code>build_document(*, id: str = 'doc-1', protocol_id: str = 'proto-1', text: str = 'Inclusion: Age &gt;= 18.', source_url: Optional[str] = None) -&gt; Document\n</code></pre> <p>Create a Document instance with defaults for tests and examples.</p> Source code in <code>components/shared/src/shared/models.py</code> <pre><code>def build_document(\n    *,\n    id: str = \"doc-1\",\n    protocol_id: str = \"proto-1\",\n    text: str = \"Inclusion: Age &gt;= 18.\",\n    source_url: Optional[str] = None,\n) -&gt; Document:\n    \"\"\"Create a Document instance with defaults for tests and examples.\"\"\"\n    return Document(\n        id=id,\n        protocol_id=protocol_id,\n        text=text,\n        source_url=source_url,\n    )\n</code></pre>"},{"location":"shared/docs/api/#shared.models.build_grounding_candidate","title":"build_grounding_candidate","text":"<pre><code>build_grounding_candidate(*, code: str = '372244006', display: str = 'Malignant melanoma, stage III', confidence: float = 0.92) -&gt; GroundingCandidate\n</code></pre> <p>Create a GroundingCandidate instance with defaults for tests and examples.</p> Source code in <code>components/shared/src/shared/models.py</code> <pre><code>def build_grounding_candidate(\n    *,\n    code: str = \"372244006\",\n    display: str = \"Malignant melanoma, stage III\",\n    confidence: float = 0.92,\n) -&gt; GroundingCandidate:\n    \"\"\"Create a GroundingCandidate instance with defaults for tests and examples.\"\"\"\n    return GroundingCandidate(\n        code=code,\n        display=display,\n        confidence=confidence,\n    )\n</code></pre>"},{"location":"shared/docs/api/#shared.models.build_hitl_edit","title":"build_hitl_edit","text":"<pre><code>build_hitl_edit(*, id: str = 'edit-1', criterion_id: str = 'crit-1', action: str = 'accept', note: Optional[str] = 'Matches protocol text', snomed_code_added: Optional[str] = None, snomed_code_removed: Optional[str] = None, field_mapping_added: Optional[str] = None, field_mapping_removed: Optional[str] = None) -&gt; HitlEdit\n</code></pre> <p>Create a HitlEdit instance with defaults for tests and examples.</p> Source code in <code>components/shared/src/shared/models.py</code> <pre><code>def build_hitl_edit(\n    *,\n    id: str = \"edit-1\",\n    criterion_id: str = \"crit-1\",\n    action: str = \"accept\",\n    note: Optional[str] = \"Matches protocol text\",\n    snomed_code_added: Optional[str] = None,\n    snomed_code_removed: Optional[str] = None,\n    field_mapping_added: Optional[str] = None,\n    field_mapping_removed: Optional[str] = None,\n) -&gt; HitlEdit:\n    \"\"\"Create a HitlEdit instance with defaults for tests and examples.\"\"\"\n    return HitlEdit(\n        id=id,\n        criterion_id=criterion_id,\n        action=action,\n        note=note,\n        snomed_code_added=snomed_code_added,\n        snomed_code_removed=snomed_code_removed,\n        field_mapping_added=field_mapping_added,\n        field_mapping_removed=field_mapping_removed,\n    )\n</code></pre>"}]}